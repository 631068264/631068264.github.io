---
layout:     post
rewards: false
title:     内存缓存
categories:
    - cache
---

如果数据缓存在站点和服务的多个节点内，数据存了多份，**一致性**比较难保障。

## 单节点通知其他节点
修改完自己内存数据与数据库中的数据之后，再通知其他节点修改内存的数据。

同一功能的一个集群的多个节点，相互耦合在一起，特别是节点较多时，网状连接关系极其复杂。

## 使用MQ
可以通过MQ通知其他节点。写请求发生在server1，在修改完自己内存数据与数据库中的数据之后，给MQ发布数据变化通知，其他server节点订阅MQ消息，也修改内存数据。

这种方案虽然解除了节点之间的耦合，但引入了MQ，使得系统更加复杂。



>前两种方案，节点数量越多，数据冗余份数越多，数据同时更新的原子性越难保证，一致性也就越难保证。

## 直接拉数据库
为了避免耦合，降低复杂性，干脆放弃了“实时一致性”，每个节点启动一个timer，定时从后端拉取最新的数据，更新内存缓存。在有节点更新后端数据，而其他节点通过timer更新数据之间，会读到脏数据。


## When 使用
- 只读数据，可以考虑在进程启动时加载到内存。
- 极其高并发的，如果透传后端压力极大的场景，可以考虑使用进程内缓存。
- 一定程度上允许数据不一致业务。

不能随便用
数据和状态尽量存储到后端的数据存储服务，例如数据库服务或者缓存服务，才能任意的加节点水平扩展。