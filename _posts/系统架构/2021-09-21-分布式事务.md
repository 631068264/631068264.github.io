---
layout:     post
rewards: false
title:      分布式事务
categories:
    - 系统架构
---


**分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上**。例如在大型电商系统中，下单接口通常会扣减库存、减去优惠、生成订单 id, 而订单服务与库存、优惠、订单 id 都是不同的服务，下单接口的成功与否，不仅取决于本地的 db 操作，而且依赖第三方系统的结果，这时候分布式事务就保证这些操作要么全部成功，要么全部失败。本质上来说，**分布式事务就是为了保证不同数据库的数据一致性。**

# 一致性

**内部一致性**

当一个服务只使用一个数据源时，多个并发事务所读写的数据能够被数据源感知是否存在冲突，并发事务的读写在时间线上的最终顺序是由数据源来确定的，这种事务间一致性被称为**内部一致性**。

**外部一致性**

当一个服务使用到多个不同的数据源，甚至多个不同服务同时涉及多个不同的数据源时，并发执行甚至是先后执行的多个事务，在时间线上的顺序并不由任何一个数据源来决定，这种涉及多个数据源的事务间一致性被称为**外部一致性**。



- 强一致性

  **任何一次读都能读到某个数据的最近一次写的数据**。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简言之，在任意时刻，所有节点中的数据是一样的。

- 弱一致性

  数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性。

- 最终一致性

  不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。简单说，就是在一段时间后，节点间的数据会最终达到一致状态。

**数据库事务的属性－ACID（四个英文单词的首写字母）：**

 - 原子性（Atomicity）

> 所谓原子性就是将一组操作作为一个操作单元，是原子操作，即要么全部执行，要么全部不执行。

 - 一致性（Consistency）

> 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

 - 隔离性（Isolation）

> 隔离性指并发的事务是相互隔离的。即一个事务内部的操作及正在操作的数据必须封锁起来，不被其它企图进行修改的事务看到。

 - 持久性（Durability）

> 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。即一旦一个事务提交，DBMS（Database
> Management System）保证它对数据库中数据的改变应该是永久性的，持久性通过数据库备份和恢复来保证。



# CAP

- **一致性（Consistence）**

  在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）

- **可用性（Availability）**

  每一个操作总是能够在**一定的时间**内**返回结果**(对数据更新具备高可用性)

- **分区容错性（Partition tolerance）**

  分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

  这里的网络分区是指由于某种原因，网络被分成若干个孤立的区域，而区域之间互不相通。

# XA协议的两阶段提交（2PC）

存在一个负责协调各个本地资源管理器的**事务管理器**，**本地资源管理器**一般是由数据库实现，

事务管理器在第一阶段的时候询问各个资源管理器是否都就绪？如果收到每个资源的回复都是 yes，则在第二阶段提交事务，如果其中任意一个资源的回复是 no, 则回滚事务。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grgg6soh4gj30xn0u0gol.jpg" style="zoom: 45%;" />

- 第一阶段（prepare）：事务管理器向所有本地资源管理器发起请求，询问是否是 ready 状态，所有参与者都将本事务能否成功的信息反馈发给协调者；
- 第二阶段 (commit/rollback)：事务管理器根据所有本地资源管理器的反馈，通知所有本地资源管理器，步调一致地在所有分支上提交或者回滚。

**缺点**

> 同步阻塞：当参与事务者存在占用公共资源的情况，其中一个占用了资源，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态。

> 单点故障：一旦事务管理器出现故障，整个系统不可用

> 数据不一致：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。

> 不确定性：当协事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。

# TCC

Try-Confirm-Cancel

1. 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。
2. 同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。
3. 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性


- Try 阶段：

  尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）

- Confirm 阶段：

  确认执行真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源，Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试。

- Cancel 阶段：

  取消执行，释放 Try 阶段预留的业务资源 Cancel 操作满足幂等性 Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致。

基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高。

# 本地消息表

![](https://tva1.sinaimg.cn/large/008i3skNgy1grggt09425j30xc0feq3m.jpg)

- A（消息生产方）**需要额外建一个消息表，并记录消息发送状态**

  同一数据库同一事务操作

    - 更新数据库的业务表
    - 更新消息表

- 消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。
- B 消费 MQ 中的消息，并处理业务逻辑。
    - 如果本地事务处理失败，会在继续消费 mq 中的消息进行重试
    - 如果业务上的失败，生产方发送一个业务补偿消息，可以通知系统 A 进行回滚操作

- 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。

# kafka事务

![](https://tva1.sinaimg.cn/large/008i3skNgy1grgifspiixj30v50erjrt.jpg)

- 上图中的 Transaction Coordinator 运行在 Kafka 服务端，下面简称 TC 服务。

- __transaction_state 是 TC 服务持久化事务信息的 topic 名称，下面简称事务 topic。

- Producer 向 TC 服务发送的 commit 消息，下面简称事务提交消息。

- TC 服务向分区发送的消息，下面简称事务结果消息。

## 事务场景

- **生产者发送多条消息可以封装在一个事务中，形成一个原子操作。**多条消息要么都发送成功，要么都发送失败。
- **read-process-write模式：将消息消费和生产封装在一个事务中，形成一个原子操作。**在一个流式处理的应用中，常常一个服务需要从上游接收消息，然后经过处理后送达到下游，这就对应着消息的消费和生成。


- [kafka系列九、kafka事务原理、事务API和使用场景](https://www.cnblogs.com/wangzhuxing/p/10125437.html)

- [Kafka 事务实现原理](https://zhmin.github.io/2019/05/20/kafka-transaction/)

