---
layout:     post
rewards: false
title:      高并发I/O
categories:
    - IO
tags:
    - IO
---
web服务的高并发性能指标可以通过**QPS**（Query per second）来衡量，QPS指每秒处理请求数，可用（并发数/一般响应时间）来计算

网络I/O过程涉及到**应用进程**以及linux**内核**两个对象，分为两个阶段
- 数据准备：通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区
- 数据拷贝：把数据从内核缓冲区复制到应用进程缓冲区


![](https://cdn.jsdelivr.net/gh/631068264/img/008i3skNgy1gqq0l83kqoj30fl06wt8z.jpg)

五种IO模型分类：

|        | 阻塞   | 非阻塞                           |
| ------ | ------ | -------------------------------- |
| 同步   | 阻塞IO | 非阻塞IO，IO多路复用，信号驱动IO |
| 异步IO |        | 异步IO                           |


# 五种IO模型

## 阻塞式I/O

进程调用recvfrom，直到数据包到达且被复制到应用程序的缓冲区或发生错误才返回。最常见的错误是系统调用信号被中断。
我们称进程在从调用recvfrom开始到返回的整段时间内是阻塞的。

BIO，通过多线程提高并发能力,解决串行问题。



当一个read操作发生时，它会经历两个阶段：
 1 等待数据准备 (Waiting for the data to be ready)
 2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)

![](https://cdn.jsdelivr.net/gh/631068264/img/008i3skNgy1gqjfvo8d41j30fc097gll.jpg)


## 非阻塞式I/O
进程**轮询数据准备的状态**，如果没准备好，则**立即返回**错误，如果准备好并且拷贝完成，则返回成功

NIO，轮询占用CPU效率,一般很少直接使用这种模型，而是在其他I/O模型中使用非阻塞I/O这一特性

![](https://cdn.jsdelivr.net/gh/631068264/img/008i3skNgy1gqq0u1dv3yj30kc0ay3yt.jpg)

## 多路复用I/O
select/poll/epoll模型，进程调用select/poll，**阻塞等待套接字变为可读**。当select返回套接字可读这一条件时，进程调用recvfrom把所读数据复制到应用进程缓冲区。

IO多路复用，使用select函数进行I/O请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。
但是使用select以后最大的优势是用户可以在**一个线程内同时处理多个socket的I/O请求**。用户可以**注册多个socket，
然后不断地调用select读取被激活的socket**，即可达到在同一个线程内同时处理多个I/O请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

调用select/poll该方法由一个用户态线程负责轮询多个socket,直到某个阶段1的数据就绪,再通知实际的用户线程执行阶段2的拷贝。通过一个专职的用户态线程执行非阻塞I/O轮询,模拟实现了阶段一的异步化。

![](https://cdn.jsdelivr.net/gh/631068264/img/008i3skNgy1gqq0s50yyqj30kc0azwes.jpg)

## 信号驱动式I/O
进程向系统**注册**感兴趣的信号，并立即返回，当数据准备完成的**信号触发**时，系统通知进程，进程调用recvfrom把所读数据复制到应用程序缓冲区。

信号驱动，在一个tcp连接的生命周期内，有大量的信号需要监听，并且信号目的难以区分，使得对于socket几乎无用，在udp服务程序中可用。


![](https://cdn.jsdelivr.net/gh/631068264/img/008i3skNgy1gqq0r6n0p9j30kc0avt8v.jpg)


## 异步I/O
进程调用系统函数，并告诉内核当整个操作完成时如何通知进程。该系统调用立即返回，而且在**等待I/O完成期间，进程不被阻塞**。**当数据准备好，并且复制到应用进程缓冲区后**，内核才会产生这个通知。

AIO，需要底层操作系统支持，而linux系统并不完全支持异步，windows提供了IOCP的接口支持异步。

![](https://cdn.jsdelivr.net/gh/631068264/img/008i3skNgy1gqq0stj41aj30kc0bqdfx.jpg)



blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。

![](https://cdn.jsdelivr.net/gh/631068264/img/008i3skNgy1gqjfz6k82mj30h2093dg0.jpg)





![](https://cdn.jsdelivr.net/gh/631068264/img/008i3skNgy1gq46s53d82j324i0n4dln.jpg)

可以看到，尽管阻塞式I/O、非阻塞式I/O、多路复用I/O、信号驱动式I/O在第一阶段的处理不同，
但在**数据拷贝阶段都处于同步阻塞等待状态**，因此可以看作是同步I/O的一种，这里的同步指的是recvfrom这个系统调用。

