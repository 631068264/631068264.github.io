---
layout:     post
rewards: false
title:   k8s helm
categories:
    - k8s
---

# 结构

## 根

Helm chart的结构如下：

```shell
mychart/
  Chart.yaml
  values.yaml
  charts/
  templates/
  ...
```

`templates/` 目录包括了模板文件。当Helm评估chart时，会通过模板渲染引擎将所有文件发送到`templates/`目录中。 然后收集模板的结果并发送给Kubernetes。

`values.yaml` 文件也导入到了模板。这个文件包含了chart的 *默认值* 。这些值会在用户执行`helm install` 或 `helm upgrade`时被覆盖。

`Chart.yaml` 文件包含了该chart的描述。你可以从模板中访问它。`charts/`目录 *可以* 包含其他的chart(称之为 *子chart*)。 指南稍后我们会看到当涉及模板渲染时这些是如何工作的。

## templates

如果你看看 `mychart/templates/` 目录，会注意到一些文件已经存在了：

- `NOTES.txt`: chart的"帮助文本"。这会在你的用户执行`helm install`时展示给他们。
- `deployment.yaml`: 创建Kubernetes [工作负载](https://kubernetes.io/docs/user-guide/deployments/)的基本清单
- `service.yaml`: 为你的工作负载创建一个 [service终端](https://kubernetes.io/docs/user-guide/services/)基本清单。
- `_helpers.tpl`: 放置可以通过chart复用的模板辅助对象



# 命令行

```bash
# 安装
helm install full-coral ./mychart
# Helm检索版本并查看实际加载的模板
helm get manifest full-coral
# 卸载发布
helm uninstall full-coral
# 测试模板渲染但又不想安装任何内容时
helm install --debug --dry-run goodly-guppy ./mychart [--set key=value]
# 单独测试子chart
helm install --generate-name --dry-run --debug mychart/charts/mysubchart

# 是验证chart是否遵循最佳实践的首选工具
helm lint
# 这是让服务器渲染模板的好方法，然后返回生成的清单文件
helm template --debug / helm install --dry-run --debug
```



# 对象

在上一部分中，我们用`{{ .Release.Name }}`在模板中插入版本名称。`Release`是你可以在模板中访问的高级对象之一。

- Release

  ： 该对象描述了版本发布本身。包含了以下对象：

  - `Release.Name`： release名称
  - `Release.Namespace`： 版本中包含的命名空间(如果manifest没有覆盖的话)
  - `Release.IsUpgrade`： 如果当前操作是升级或回滚的话，需要将该值设置为`true`
  - `Release.IsInstall`： 如果当前操作是安装的话，需要将该值设置为`true`
  - `Release.Revision`： 此次修订的版本号。安装时是1，每次升级或回滚都会自增
  - `Release.Service`： 该service用来渲染当前模板。Helm里一般是`Helm`

- `Values`： Values是从`values.yaml`文件和用户提供的文件传进模板的。`Values`默认为空

- Chart：Chart.yaml文件内容。Chart.yaml里的任意数据在这里都可以可访问的。比如{{ .Chart.Name }}-{{ .Chart.Version }}会打印出mychart-0.1.0

  - [Chart 指南](https://helm.sh/zh/docs/topics/charts#Chart-yaml-文件) 中列出了可用字段

- Files

  在chart中提供访问所有的非特殊文件。当你不能使用它访问模板时，你可以访问其他文件。 这个 [文件访问](https://helm.sh/zh/docs/chart_template_guide/accessing_files)部分了解更多信息

  - `Files.Get` 通过文件名获取文件的方法。 （`.Files.Getconfig.ini`）
  - `Files.GetBytes` 用字节数组代替字符串获取文件内容的方法。 对图片之类的文件很有用
  - `Files.Glob` 用给定的shell glob模式匹配文件名返回文件列表的方法
  - `Files.Lines` 逐行读取文件内容的方法。迭代文件中每一行时很有用
  - `Files.AsSecrets` 使用Base 64编码字符串返回文件体的方法
  - `Files.AsConfig` 使用YAML格式返回文件体的方法

- Capabilities

  ： 提供关于Kubernetes集群支持功能的信息

  - `Capabilities.APIVersions` 是一个版本集合
  - `Capabilities.APIVersions.Has $version` 说明集群中的版本 (e.g., `batch/v1`) 或是资源 (e.g., `apps/v1/Deployment`) 是否可用
  - `Capabilities.KubeVersion` 和 `Capabilities.KubeVersion.Version` 是Kubernetes的版本号
  - `Capabilities.KubeVersion.Major` Kubernetes的主版本
  - `Capabilities.KubeVersion.Minor` Kubernetes的次版本
  - `Capabilities.HelmVersion` 包含Helm版本详细信息的对象，和 `helm version` 的输出一致
  - `Capabilities.HelmVersion.Version` 是当前Helm版本的语义格式
  - `Capabilities.HelmVersion.GitCommit` Helm的git sha1值
  - `Capabilities.HelmVersion.GitTreeState` 是Helm git树的状态
  - `Capabilities.HelmVersion.GoVersion` 是使用的Go编译器版本

- Template

  ： 包含了已经被执行的当前模板信息

  - `Template.Name`: 当前模板的命名空间文件路径 (e.g. `mychart/templates/mytemplate.yaml`)
  - `Template.BasePath`: 当前chart模板目录的路径 (e.g. `mychart/templates`)

内置的值都是以大写字母开始。 这是符合Go的命名惯例。当你创建自己的名称时，可以按照团队约定自由设置。 就像很多你在 [Artifact Hub](https://artifacthub.io/packages/search?kind=0) 中看到的chart，其团队选择使用首字母小写将本地名称与内置对象区分开，本指南中我们遵循该惯例。

# 子chart

但chart可以使用依赖，称为 *子chart*，且有自己的值和模板。 该章节我们会创建一个子chart并能看到访问模板中的值的不同方式。

在深入研究代码之前，需要了解一些子chart的重要细节：

1. 子chart被认为是“独立的”，意味着子chart从来不会显示依赖它的父chart。
2. 因此，子chart无法访问父chart的值。
3. 父chart可以覆盖子chart的值。
4. Helm有一个 *全局值* 的概念，所有的chart都可以访问。

为了做这些练习，我们可以从本指南开始时创建的`mychart/`开始，并在其中添加一个新的chart。

```bash
$ cd mychart/charts
$ helm create mysubchart
Creating mysubchart
$ rm -rf mysubchart/templates/*
```

