---
layout:     post
rewards: false
title:   k8s容器资源
categories:
    - k8s
---

定义 [Pod](https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/) 时可以选择性地为每个 [容器](https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/#why-containers)设定所需要的资源数量。 最常见的可设定资源是 CPU 和内存（RAM）大小；此外还有其他类型的资源。

当你为 Pod 中的 Container 指定了资源 **请求** 时，调度器就利用该信息决定将 Pod 调度到哪个节点上。 当你还为 Container 指定了资源 **约束** 时，kubelet 就可以确保运行的容器不会使用超出所设约束的资源。 kubelet 还会为容器预留所 **请求** 数量的系统资源，供其使用。

# Requests and limits

如果 Pod 运行所在的节点具有足够的可用资源，**容器可能（且可以）使用超出对应资源 `request` 属性所设置的资源量**。不过，容器不可以使用超出其资源 `limit` 属性所设置的资源量。



# 资源类型

*CPU* 和*内存*都是*资源类型*。每种资源类型具有其基本单位。

Pod 中的每个容器都可以指定以下的一个或者多个值：

- `spec.containers[].resources.limits.cpu`
- `spec.containers[].resources.limits.memory`
- `spec.containers[].resources.limits.hugepages-<size>`
- `spec.containers[].resources.requests.cpu`
- `spec.containers[].resources.requests.memory`
- `spec.containers[].resources.requests.hugepages-<size>`

尽管请求和限制值只能在单个容器上指定，我们仍可方便地计算出 Pod 的资源请求和约束。 Pod 对特定资源类型的请求/约束值是 Pod 中各容器对该类型资源的请求/约束值的总和。



`spec.containers[].resources.requests.cpu` 为 **0.5 的 Container 肯定能够获得请求 1 CPU 的容器的一半 CPU 资源**。表达式 `0.1` 等价于表达式 100m，具有小数点（如 `0.1`）的请求由 API 转换为 `100m`；最大精度是 `1m`。



内存的约束和请求以字节为单位。你可以使用以下后缀之一以一般整数或定点数字形式来表示内存： E、P、T、G、M、k。你也可以使用对应的 2 的幂数：Ei、Pi、Ti、Gi、Mi、Ki。 例如，以下表达式所代表的是大致相同的值



```yaml
apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: app
    image: images.my-company.example/app:v4
    env:
    - name: MYSQL_ROOT_PASSWORD
      value: "password"
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
  - name: log-aggregator
    image: images.my-company.example/log-aggregator:v6
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "128Mi"
        cpu: "500m"
```

# 带资源约束的 Pod 如何运行

当 kubelet 启动 Pod 中的 Container 时，它会将 CPU 和内存约束信息传递给容器运行时。

当使用 Docker 时：

- `spec.containers[].resources.requests.cpu` 先被转换为可能是小数的基础值，再乘以 1024。 这个数值和 2 的较大者用作 `docker run` 命令中的 [`--cpu-shares`](https://docs.docker.com/engine/reference/run/#/cpu-share-constraint) 标志的值。

- `spec.containers[].resources.limits.cpu` 先被转换为 millicore 值，再乘以 100。 其结果就是每 100 毫秒内容器可以使用的 CPU 时间总量。在此期间（100ms），容器所使用的 CPU 时间不会超过它被分配的时间。

  > **说明：** 默认的配额（Quota）周期为 100 毫秒。CPU 配额的最小精度为 1 毫秒。

- `spec.containers[].resources.limits.memory` 被转换为整数值，作为 `docker run` 命令中的 [`--memory`](https://docs.docker.com/engine/reference/run/#/user-memory-constraints) 参数值。

如果 Container 超过其内存限制，则可能会被终止。如果容器可重新启动，则与所有其他类型的 运行时失效一样，kubelet 将重新启动容器。

如果一个 Container 内存用量超过其内存请求值，那么当节点内存不足时，容器所处的 Pod 可能被逐出。

每个 Container 可能被允许也可能不被允许使用超过其 CPU 约束的处理时间。 但是，容器不会由于 CPU 使用率过高而被杀死。
