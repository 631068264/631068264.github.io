---
layout:     post
rewards: false
title:      k8s集群调度
categories:
    - k8s

---

集群中多台服务的配置是不一致的。这就导致资源分配并不是均匀的，比如我们需要有些服务节点用来运行计算密集型的服务，而有些服务节点来运行需要大量内存的服务。而在 k8s 中当然也配置了相关服务来处理上述的问题，那就是 Scheduler。

Scheduler 是 kubernetes 的调度器，主要的任务是把定义的 Pod 分配到集群的节点上。听起来非常简单，但有很多要考虑的问题：

- 公平

- - 如何保证每个节点都能被分配资源

- 资源高效利用

- - 集群所有资源最大化被使用

- 效率

- - 调度的性能要好，能够尽快地对大批量的 Pod 完成调度工作

- 灵活

- - 允许用户根据自己的需求控制调度的逻辑

Scheduler 是作为单独的程序运行的，启动之后会一直坚挺 API Server，获取 PodSpec.NodeName 为空的 Pod，对每个 Pod 都会创建一个 binding，表明该 Pod 应该放到哪个节点上。

# 调度过程

调度分为几个部分

**首先是过滤掉不满足条件的节点，这个过程称为 predicate**；然后对通过的节点按照优先级排序，这个是 priority；最后从中选择优先级最高的节点。如果中间任何一步骤有错误，就直接返回错误。Predicate 有一系列的算法可以使用：

- `PodFitsResources`
  - 节点上剩余的资源是否大于 `pod` 请求的资源
- `PodFitsHost`
  - 如果 `pod` 指定了 `NodeName`，检查节点名称是否和 `NodeName` 匹配
- `PodFitsHostPorts`
  - 节点上已经使用的 `port` 是否和 `pod` 申请的 `port` 冲突
- `PodSelectorMatches`
  - 过滤掉和 `pod` 指定的 `label` 不匹配的节点
- `NoDiskConflict`
  - 已经 `mount` 的 `volume` 和 `pod` 指定的 `volume` 不冲突，除非它们都是只读

**如果在 predicate 过程中没有合适的节点，pod 会一直在 pending 状态，不断重试调度，直到有节点满足条件。经过这个步骤，如果有多个节点满足条件，就继续 priorities 过程**：按照优先级大小对节点排序。优先级由一系列键值对组成，键是该优先级项的名称，值是它的权重（该项的重要性）。这些优先级选项包括：

- `LeastRequestedPriority`
  - 通过计算 CPU 和 Memory 的使用率来决定权重，使用率越低权重越高。换句话说，这个优先级指标倾向于资源使用比例更低的节点。
- `BalancedResourceAllocation`
  - 节点上 CPU 和 Memory 使用率越接近，权重越高。这个应该和上面的一起使用，不应该单独使用。
- `ImageLocalityPriority`
  - 倾向于已经有要使用镜像的节点，镜像总大小值越大，权重越高。

通过算法对所有的优先级项目和权重进行计算，得出最终的结果。

# 自定义调度器

除了 kubernetes 自带的调度器，你也可以编写自己的调度器。通过 spec:schedulername 参数指定调度器的名字，可以为 pod 选择某个调度器进行调度。比如下面的 pod 选择 my-scheduler 进行调度，而不是默认的 default-scheduler。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: annotation-second-scheduler
  labels:
    name: multischeduler-example
spec:
  schedulername: my-scheduler
  containers:
    - name: pod-with-second-annotation-container
      image: gcr.io/google_containers/pause:2.1
```

# 亲和性

亲和性包括：节点亲和 Pod 亲和性

亲和性简而言之就是，表示我们部署的服务更加趋向于运行那些节点上面，增加了服务的部署可控性。

## 节点亲和性

**pod.spec.nodeAffinity**

- **键值运算关系**

| 编号 | 运算关系       | 对应说明解释               |
| :--- | :------------- | :------------------------- |
| 1    | `In`           | `label` 的值在某个列表中   |
| 2    | `NotIn`        | `label` 的值不在某个列表中 |
| 3    | `Gt`           | `label` 的值大于某个值     |
| 4    | `Lt`           | `label` 的值小于某个值     |
| 5    | `Exists`       | 某个 `label` 存在          |
| 6    | `DoesNotExist` | 某个 `label` 不存在        |

```bash
# 每个节点都有标识来标识自己
# kubernetes.io/hostname; kubernetes.io/arch
$ kubectl get node --show-labels
NAME          STATUS   ROLES                  AGE    VERSION   LABELS
k8s-node1     Ready    <none>                 3d     v1.19.4   kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node1,kubernetes.io/os=linux
k8s-node2     Ready    <none>                 3d     v1.19.4   kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-node2,kubernetes.io/os=linux
k8s-master    Ready    control-plane,master   5d     v1.19.4   kubernetes.io/arch=amd64,kubernetes.io/hostname=k8s-master,kubernetes.io/os=linux,node-role.kubernetes.io/control-plane=,node-role.kubernetes.io/master=
```

- **硬策略 - requiredDuringSchedulingIgnoredDuringExecution**

  ```yaml
  apiVersion: v1
  kind: Pod
  metadata:
    name: affinity
    labels:
      app: node-affinity-pod
  spec:
    containers:
      - name: with-node-affinity
        image: hub.escape.com/library/myapp:v1
    affinity:
      nodeAffinity:
        requiredDuringSchedulingIgnoredDuringExecution:
          nodeSelectorTerms:
            - matchExpressions:
                - key: kubernetes.io/hostname
                  operator: NotIn
                  values:
                    - k8s-node
  ```

- **软策略 - preferredDuringSchedulingIgnoredDuringExecution**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: affinity
  labels:
    app: node-affinity-pod
spec:
  containers:
    - name: with-node-affinity
      image: hub.escape.com/library/myapp:v1
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 1
          preference:
            matchExpressions:
              - key: source
                operator: In
                values:
                  - test
```

- **硬软策略合体**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: affinity
  labels:
    app: node-affinity-pod
spec:
  containers:
    - name: with-node-affinity
      image: hub.escape.com/library/myapp:v1
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: kubernetes.io/hostname
                operator: NotIn
                values:
                  - k8s-node
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 1
          preference:
            matchExpressions:
              - key: source
                operator: In
                values:
                  - test
```

## Pod 亲和性

**pod.spec.affinity.podAffinity/podAntiAffinity**

- **硬策略 - requiredDuringSchedulingIgnoredDuringExecution**
- **软策略 - preferredDuringSchedulingIgnoredDuringExecution**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-3
  labels:
    app: pod-3
spec:
  containers:
    - name: pod-3
      image: hub.escape.com/library/myapp:v1
      affinity:
        podAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - pod-1
              topologyKey: kubernetes.io/hostname
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - pod-2
                topologyKey: kubernetes.io/hostname
```

- **亲和性/反亲和性调度策略比较**

  ![image-20211017220718356](https://tva1.sinaimg.cn/large/008i3skNgy1gvintmqwimj61920femz002.jpg)

# 污点和容忍

节点亲和性，是 pod 的一种属性（偏好或硬性要求），它使 pod 被吸引到一类特定的节点。Taint 则相反，它使节点能够排斥一类特定的 pod。

Taint 和 toleration 相互配合，可以用来避免 pod 被分配到不合适的节点上。每个节点上都可以应用一个或多个 taint，这表示对于那些不能容忍这些 taint 的 pod，是不会被该节点接受的。如果将 toleration 应用于 pod 上，则表示这些 pod 可以（但不要求）被调度到具有匹配 taint 的节点上。

## 污点**Taint**

污点的组成 使用 kubectl taint 命令可以给某个 Node 节点设置污点，Node 被设置上污点之后就和 Pod 之间存在了一种相斥的关系，可以让 Node 拒绝 Pod 的调度执行，甚至将 Node 已经存在的 Pod 驱逐出去。每个污点的组成如下：

```
key=value:effect
```

每个污点有一个 key 和 value 作为污点的标签，其中 value 可以为空，effect 描述污点的作用。当前 taint effect 支持如下三个选项：

- NoSchedule

- - 表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上

- PreferNoSchedule

- - 表示 k8s 将尽量避免将 Pod 调度到具有该污点的 Node 上

- NoExecute

- - 表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上，同时会将 Node 上已经存在的 Pod 驱逐出去

```bash
# master节点默认自带污点
$ kubectl get node
NAME          STATUS   ROLES                  AGE  VERSION
k8s-node1     Ready    <none>                 3d   v1.20.0
k8s-node2     Ready    <none>                 5d   v1.20.0
k8s-master    Ready    control-plane,master   5d   v1.20.0

# 查看master及诶单的抹点标识
$ kubectl describe node k8s-master
Taints: node-role.kubenetes.io/master:NoSchedule
```

- 污点的设置、查看和去除

  ```bash
  # 设置污点
  $ kubectl taint nodes k8s-node1 key1=value1:NoSchedule
  $ kubectl taint nodes k8s-node1 type=master:NoExecute
  
  # 节点说明中查找Taints字段
  $ kubectl describe pod pod-name
  
  # 去除污点
  $ kubectl taint nodes k8s-node1 key1:NoSchedule-
  ```

## 容忍 **Tolerations**

设置了污点的 Node 将根据 taint 的 effect：NoSchedule、PreferNoSchedule、NoExecute 和 Pod 之间产生互斥的关系，Pod 将在一定程度上不会被调度到 Node 上。但我们可以在 Pod 上设置容忍，意思是设置了容忍的 Pod 将可以容忍污点的存在，可以被调度到存在污点的 Node 上。

- pod.spec.tolerations

- - 其中 operator 的值为 Exists 将会忽略 value 值
  - 其中 key, value, effect 要与 Node 上设置的 taint 保持一致
  - 其中 tolerationSeconds 用于描述当 Pod 需要被驱逐时可以在 Pod 上继续保留运行的时间

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-3
  labels:
    app: pod-3
spec:
  containers:
    - name: pod-3
      image: hub.escape.com/library/myapp:v1
  tolerations:
    - key: "type"
      operator: "Equal"
      value: "master"
      effect: "NoSchedule"
      tolerationSeconds: 3600
    - key: "type"
      operator: "Equal"
      value: "master"
      effect: "NoExecute"
    - key: "type"
      operator: "Exists"
      effect: "NoSchedule"
```

**当不指定 key 值时，表示容忍所有的污点 key**

```yaml
tolerations:
  operator: "Exists"
```

 **当不指定 effect 值时，表示容忍所有的污点作用**

```yaml
tolerations:
  - key: "key"
    operator: "Exists"
```

**有多个 Master 存在时，防止资源浪费，可以如下设置**

```yaml
# 尽可能不在Master节点运行
$ kubectl taint nodes Node-Name node-role.kubernetes.io/master=:PreferNoSchedule
```

# 指定调度节点

- Pod.spec.nodeName

- - 将 Pod 直接调度到指定的 Node 节点上，会跳过 Scheduler 的调度策略，该匹配规则是强制匹配。

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: myweb
spec:
  replicas: 7
  template:
    metadata:
      labels:
        app: myweb
    spec:
      nodeName: k8s-node1
      containers:
        - name: myweb
          image: hub.escape.com/library/myapp:v1
          ports:
            - containerPort: 80
```

- Pod.spec.nodeSelector
  - 通过 `kubernetes` 的 `label-selector` 机制选择节点，由调度器调度策略匹配 `label`，而后调度 `Pod` 到目标节点，该匹配规则属于强制约束。

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: myweb
spec:
  replicas: 2
  template:
    metadata:
      labels:
        app: myweb
    spec:
    nodeSelector:
      type: BackendNode
    containers:
      - name: myweb
        image: hub.escape.com/library/myapp:v1
        ports:
          - containerPort: 80
```

