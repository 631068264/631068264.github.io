---
layout:     post
rewards: false
title:      å¯†ç 
categories:
    - hack
tags:
    - å¯†ç 
---

# ç§é’¥/å…¬é’¥åŠ å¯†ç®—æ³•ï¼ˆå¯¹ç§°/éå¯¹ç§°ï¼‰

<span class='heimu'>å¾ˆè®¨åŒä¸€æ ·ä¸œè¥¿æœ‰ä¸¤æ ·åå­—ï¼Œè€ƒé¢˜è€ƒå®˜æ€»èƒ½æ‹¿æ²¡å¬è¿‡çš„è€ƒä½ </span>ğŸ¤£

ç®—æ³•ç”Ÿæˆä¸€å¯¹å¯†é’¥ç”¨äºåŠ å¯†è§£å¯†
- å¯†é’¥ç›¸åŒ **å¯¹ç§°/ç§é’¥ åŠ å¯†**
- å¯†é’¥ä¸åŒ **éå¯¹ç§°/å…¬é’¥ åŠ å¯†** å…¬é’¥å¯å…¬å¼€ï¼Œç§é’¥è‡ªå·±ç•™ç€ï¼Œ**åŒä¸€å¯†é’¥å¯¹å¯ä»¥è§£å¯¹æ–¹åŠ çš„å¯†**

## å¸¸ç”¨ç®—æ³•

### å¯¹ç§°
AES,DES,3DESï¼ŒRC5ã€RC6

> åŠ å¯†è§£å¯†æ•ˆç‡é«˜ï¼Œ**é€Ÿåº¦å¿«**ï¼Œé€‚åˆè¿›è¡Œ**å¤§æ•°æ®é‡**çš„åŠ è§£å¯†

### éå¯¹ç§°
RSAã€DSAã€ECC

> ç®—æ³•å¤æ‚ï¼ŒåŠ è§£å¯†**é€Ÿåº¦æ…¢**ï¼Œä½†**å®‰å…¨æ€§é«˜**

### hash

MD5ã€SHAç³»åˆ—ã€HMAC åŠ ç›

åŒè¾“å…¥åŒç®—æ³•åŒè¾“å‡ºï¼ŒåŒè¾“å‡ºä¸ä¸€å®šè¾“å…¥ç›¸åŒ(**ä¸èƒ½åæ¨**)


# å¯†é’¥çš„æ ¼å¼

## ASN.1 format

æœ¬èº«åªæ˜¯è¡¨ç¤ºæ¥å£æ•°æ®çš„é€šç”¨è¯­æ³•ï¼Œæ²¡æœ‰é™å®šç¼–ç æ–¹æ³•ã€‚æ˜¯ä¸€ç§åè®®

**RSA**ç”Ÿæˆçš„å¯†é’¥å°±æ˜¯ä½¿ç”¨ASN.1ä¸­çš„**DER(Distinguished Encoding Rules)**æ¥ç¼–ç æˆäºŒè¿›åˆ¶

**PEM** å¯¹DERç¼–ç è½¬ç ä¸ºBase64ï¼Œè§£ç åï¼Œå¯ä»¥è¿˜åŸä¸º**DER**æ ¼å¼

```
-----BEGIN PUBLIC KEY-----
xxx
-----END PUBLIC KEY-----
```

## PEM æ ¼å¼

- PKCS1

ä¸“é—¨ä¸º RSA å¯†é’¥è¿›è¡Œå®šä¹‰ æœ‰ **RSA** å­—æ ·

```
-----BEGIN RSA PRIVATE KEY-----
BASE64 DATA
-----END RSA PRIVATE KEY-----
```

- PKCS8

ä¸€ç§å¯†é’¥æ ¼å¼çš„é€šç”¨æ–¹æ¡ˆï¼Œä¸ä»…ä»…ä¸º RSA æ‰€ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥è¢«å…¶å®ƒå¯†é’¥æ‰€ä½¿ç”¨


# æ¶ˆæ¯åŠ å¯†

> é€šä¿¡å®‰å…¨

ç”¨**éå¯¹ç§°åŠ å¯†**ï¼Œ**å¯¹ç§°**çš„è¯å¯†é’¥æ³„æ¼å°±å®Œè›‹

- S : å‘é€è€…
- R : æ¥æ”¶è€…

$$
R\xrightarrow{\mathrm{å…¬é’¥}}S
$$

$$
S: R\mathrm{å…¬é’¥}+\mathrm{åŸå§‹ä¿¡æ¯}=\mathrm{å¯†æ–‡}
$$

$$
S\xrightarrow{\mathrm{å¯†æ–‡}}R
$$

$$
R:\;R\mathrm{ç§é’¥}+\mathrm{å¯†æ–‡}=\mathrm{åŸå§‹ä¿¡æ¯}
$$



# æ•°å­—ç­¾å

> ç¡®ä¿æ¶ˆæ¯**æ¥æº**,**ä¸è¢«ç¯¡æ”¹**

- S : å‘é€è€…
- R : æ¥æ”¶è€…
- M: Man-in-the-middle attack


$$
 S\xrightarrow{\mathrm{å…¬é’¥}}R 
$$

$$
S\;:\;\mathrm{åŸå§‹æ¶ˆæ¯}+\;HASH=\mathrm{æ‘˜è¦}(digest)+\;S\mathrm{ç§é’¥åŠ å¯†}\;=\;\mathrm{æ•°å­—ç­¾å}(signature)
$$

$$
S\xrightarrow{\mathrm{åŸå§‹æ¶ˆæ¯}\;and\;\;\mathrm{æ•°å­—ç­¾å}}R
$$

$$
R\;\left\{\begin{array}{l}\mathrm{åŸå§‹æ¶ˆæ¯}\;\xrightarrow[{HASH}]{}\mathrm{æ‘˜è¦}A\\\mathrm{åŠ å¯†æ‘˜è¦}\xrightarrow[{\mathrm{Så…¬é’¥è§£å¯†}\;\;\;}]{}\mathrm{æ‘˜è¦}B\end{array}\rightarrow\right.\mathrm{æ‘˜è¦}A/B\mathrm{å¯¹æ¯”}\rightarrow\mathrm{æ¶ˆæ¯æ˜¯å¦è¢«ç¯¡æ”¹}
$$



> è¿™é‡Œçš„åŸå§‹æ¶ˆæ¯ä¹Ÿ**å¯ä»¥ç»è¿‡åŠ å¯†ï¼Œè¿™æ ·å°±ä¸æ˜¯æ˜æ–‡äº†ï¼Œå®‰å…¨æ€§æ›´å¥½**



- Why åŠ å¯†æ‘˜è¦ not ç›´æ¥å‘æ‘˜è¦

> ç›´æ¥å‘æ‘˜è¦Må¯ä»¥æ›¿æ¢å‘é€çš„æ¶ˆæ¯å’Œæ‘˜è¦ï¼Œä½†æ— æ³•å®ŒæˆåŠ å¯†ã€‚**é€šè¿‡ç§é’¥åŠ å¯†è¯æ˜å‘é€è€…çš„èº«ä»½**ï¼Œåªæœ‰å”¯ä¸€çš„å…¬é’¥è§£å¯†ï¼Œå…¶ä»–äººæ— æ³•ä¼ªé€ ã€‚

- Why åŠ å¯†æ‘˜è¦ not åŠ å¯†æ¶ˆæ¯

> æ¶ˆæ¯é‡å¤§çš„è¯åŠ å¯†æ—¶é—´é•¿ï¼Œæ‘˜è¦æ˜¯å›ºå®šé•¿åº¦çš„ã€‚


# æ•°å­—è¯ä¹¦

å½“Ræ‹¿åˆ°Så…¬é’¥å…¶å®æ˜¯**Må…¬é’¥**æ—¶ï¼Œä¸€åˆ‡å´©åã€‚Må¯ä»¥å®Œå…¨å–ä»£Så‘é€æ¶ˆæ¯ï¼ŒRä¼šè§‰å¾—Mæ‰æ˜¯Sï¼ŒSæ˜¯å…¶ä»–äººã€‚

> **è¯ä¹¦ä¸­å¿ƒ**ï¼ˆcertificate authorityï¼Œç®€ç§°CAï¼‰ä¸ºå…¬é’¥åšè®¤è¯ã€‚è¯ä¹¦ä¸­å¿ƒç”¨è‡ªå·±çš„ç§é’¥ï¼Œå¯¹Så…¬é’¥å’Œä¸€äº›ç›¸å…³ä¿¡æ¯ä¸€èµ·**åŠ å¯†ç­¾å**ï¼Œç”Ÿæˆ**æ•°å­—è¯ä¹¦**ï¼ˆDigital Certificateï¼‰


$$
{\mathrm{è¯ä¹¦ä¸­å¿ƒ}(certificate\;authority)\mathrm{ç§é’¥}}+S\mathrm{å…¬é’¥}+\mathrm{ä¸€äº›}S\mathrm{çš„ä¿¡æ¯}=\mathrm{æ•°å­—è¯ä¹¦}(Digital\;Certificate)
$$

$$
S\xrightarrow{\mathrm{åŸå§‹æ¶ˆæ¯}\;and\;\;\mathrm{æ•°å­—ç­¾å}\;}R
$$

$$
R:\;\mathrm{æ•°å­—ç­¾å}+CA\;\mathrm{å…¬é’¥}=S\mathrm{å…¬é’¥} 
$$



çŸ¥åCAæœºæ„çš„æ ¹è¯ä¹¦ä¼šå†…ç½®äºæ¸¸è§ˆå™¨ä¸­ï¼Œç”¨æ¥ç¡®ä¿ CA æœºæ„æœ¬èº«çš„èº«ä»½ï¼Œå…¶ä¸­å°±åŒ…å«äº† CA æœºæ„è‡ªèº«çš„å…¬é’¥ã€‚ä¼šéªŒè¯æ•°å­—è¯ä¹¦å¯é æ€§ã€‚

- Why CA å…¬é’¥éä¼ªé€ 
> CAæ˜¯ç¬¬ä¸‰æ–¹æœºæ„ï¼ŒCAå…¬é’¥æ˜¯å…¬å¼€çš„ï¼Œæ¥æ”¶æ–¹å¯ä»¥è·Ÿåˆ«äººæ¯”å¯¹ï¼ˆæ¯”å¦‚åœ¨ç½‘ä¸ŠæŸ¥è¯¢ï¼‰ï¼Œå› æ­¤ä¸å¯èƒ½ä¼ªé€ ã€‚ä½†æ˜¯å‘é€æ–¹å…¬é’¥ï¼Œæ¥æ”¶æ–¹æ˜¯é€šè¿‡é€šä¿¡å¾—åˆ°çš„ï¼Œæ”¶åˆ°åæ— æ³•éªŒè¯ã€‚



## è‡ªç­¾åè¯ä¹¦

```
openssl req -newkey rsa:2048 -nodes -keyout client.key -x509 -days 36500 -out client.crt
```

**Common Name** å¦‚æœæ‚¨ä½¿ç”¨ SSL åŠ å¯†ä¿æŠ¤ç½‘ç»œæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¹‹é—´çš„æ•°æ®æµï¼Œä¸¾ä¾‹è¢«ä¿æŠ¤çš„ç½‘ç«™æ˜¯ https://test.chinacloudsites.cnï¼Œé‚£ä¹ˆæ­¤å¤„ Common Name åº”è¾“å…¥ test.chinacloudsites.cn


## CAè‡ªç­¾å


### è‡ªç­¾ CA è¯ä¹¦

```
mkdir -p ./demoCA/newcerts
touch ./demoCA/index.txt
echo "01" > ./demoCA/serial

```

ä¿®æ”¹ openssl.cnf dirå±æ€§ æˆ–è€…**cp**ç­‰

```
[ CA_default ]

dir             = ./demoCA              # Where everything is kept                                                                                                      
certs           = $dir/certs            # Where the issued certs are kept
crl_dir         = $dir/crl              # Where the issued crl are kept
database        = $dir/index.txt        # database index file.
#unique_subject = no                    # Set to 'no' to allow creation of
                                        # several ctificates with same subject.
new_certs_dir   = $dir/newcerts         # default place for new certs.

certificate     = $dir/cacert.pem       # The CA certificate
serial          = $dir/serial           # The current serial number
crlnumber       = $dir/crlnumber        # the current crl number

```

ç”Ÿæˆ ca.key ca.crt ç”Ÿæˆæ‰©å±•åä¸º.crt çš„æ ¹è¯ä¹¦æ–‡ä»¶å’Œæ‰©å±•åä¸º.key çš„å…¬é’¥, ç”Ÿæˆçš„è¯ä¹¦å’Œå…¬é’¥å¯èƒ½æ˜¯.PEM ç¼–ç æ ¼å¼ï¼Œä¹Ÿå¯èƒ½æ˜¯.DER ç¼–ç æ ¼å¼ã€‚

```
openssl req -newkey rsa:2048 -nodes -keyout ca.key -x509 -days 36500 -out ca.crt
```

optional

```
cat ca.crt ca.key > ca.cer
```

X.509 è¯ä¹¦ç¼–ç æ ¼å¼ä¸»è¦æœ‰ä¸¤ç§ï¼š **.PEM** å’Œ**.DER**ã€‚

- .DER æ˜¯äºŒè¿›åˆ¶ç¼–ç ï¼Œå¯åŒ…å«æ‰€æœ‰ç§é’¥ã€å…¬é’¥å’Œè¯ä¹¦ï¼Œæ˜¯å¤§å¤šæ•°æµè§ˆå™¨çš„ç¼ºçœæ ¼å¼ï¼Œå¸¸è§äº Windows ç³»ç»Ÿä¸­çš„è¯ä¹¦æ ¼å¼ã€‚

- .PEM æ˜¯æ˜æ–‡æ ¼å¼çš„, ä»¥ **-----BEGIN CERTIFICATE-----** å¼€å¤´ï¼Œå·² **-----END CERTIFICATE-----** ç»“å°¾,
  ä¸­é—´æ˜¯ç»è¿‡ base64 ç¼–ç çš„å†…å®¹, Apache å’Œ NGINX æœåŠ¡å™¨åå‘äºä½¿ç”¨è¿™ç§ç¼–ç æ ¼å¼ï¼Œä¹Ÿæ˜¯ openssl é»˜è®¤é‡‡ç”¨çš„ä¿¡æ¯å­˜æ”¾æ–¹å¼ã€‚
  PEM å…¶å®å°±æ˜¯æŠŠ DER çš„å†…å®¹è¿›è¡Œäº†ä¸€æ¬¡ base64 ç¼–ç ã€‚

è¯ä¹¦ç¼–ç æ ¼å¼è½¬æ¢

- PEM to DER :`openssl x509 -in cacert.crt -outform der -out cacert.der`
- DER to PEM :`openssl x509 -in cert.crt -inform der -outform pem -out cacert.pem`
- PEM to CRT :`openssl x509 -outform der -in your-cert.pem -out your-cert.crt`
- CRT to PEM :`openssl x509 -inform der -in certificate.cer -out certificate.pem`


### ç­¾å‘è¯ä¹¦

ç”Ÿæˆç§é’¥

```shell
openssl genrsa -out server.key 2048
```

ç”Ÿæˆè¯ä¹¦ç­¾åè¯·æ±‚ï¼Œæ‰©å±•å.csr

```shell
openssl req -days 36500 -new -key server.key -out server.csr
```

ä½¿ç”¨ CA æ ¹è¯ä¹¦ç­¾å‘

```shell
openssl ca -days 36500 -in server.csr -out server.crt -cert ca.crt -keyfile ca.key
```



æŸ¥çœ‹`*.crt`æ–‡ä»¶çš„æœ‰æ•ˆæœŸ

```shell
openssl x509 -in domain.crt -noout -dates
openssl x509 -in domain.crt -noout -text
openssl x509 -in domain.crt -noout -subject
```



## SANè¯ä¹¦

- **SAN**æ˜¯**Subject** Alternative Name**çš„é¦–å­—æ¯****ç¼©å†™**è¯
- è¿™äº›è¯ä¹¦çš„æˆæœ¬é€šå¸¸æ¯”å•åè¯ä¹¦é«˜ä¸€ç‚¹ï¼Œå› ä¸ºå®ƒä»¬å…·æœ‰æ›´å¤šåŠŸèƒ½ã€‚
- å½“æ‚¨è¯·æ±‚ SAN è¯ä¹¦æ—¶ï¼Œæ‚¨å¯ä»¥é€‰æ‹©å®šä¹‰è¯ä¹¦å¯ä»¥ä¿æŠ¤çš„å¤šä¸ª DNS åç§°ã€‚
- é¢å‘åï¼ŒSAN è¯ä¹¦å°†åŒ…å«ä¸» DNS åç§°ï¼Œè¯¥åç§°é€šå¸¸æ˜¯ç½‘ç«™çš„ä¸»åç§°ï¼Œå¹¶ä¸”åœ¨è¯ä¹¦å±æ€§çš„æ›´æ·±å¤„ï¼Œæ‚¨ä¼šå‘ç°åˆ—å‡ºäº†æ‚¨åœ¨è¯·æ±‚æœŸé—´æŒ‡å®šçš„å…¶ä»– DNS åç§°ã€‚
- æ­¤å•ä¸€è¯ä¹¦å¯ä»¥å®‰è£…åœ¨ Web æœåŠ¡å™¨ä¸Šï¼Œå¹¶ç”¨äºéªŒè¯è¯ä¹¦ä¸­åŒ…å«çš„ä»»ä½• DNS åç§°çš„æµé‡ã€‚

go version > 1.15æœ‰å…³ï¼Œé«˜ç‰ˆæœ¬å¼ƒç”¨CN(CommonName) å­—æ®µï¼Œè¯ä¹¦å¿…é¡»æœ‰SANï¼ˆ**Subject Alternative Names**ï¼‰ï¼Œä¸ç„¶ä¼šæŠ¥é”™[x509: certificate relies on legacy Common Name fieldã€‚](https://jfrog.com/knowledge-base/general-what-should-i-do-if-i-get-an-x509-certificate-relies-on-legacy-common-name-field-error/)

### ç”Ÿæˆè¯ä¹¦

æ™®é€š xxxæ˜¯åŸŸå

```sh
openssl req -x509 -sha256 -nodes -days 36500 -newkey rsa:2048 -keyout server.key -out server.crt -subj "/CN=xxxx" -addext "subjectAltName = DNS:xxxx"
```

å¤æ‚ç¼–è¾‘x509 openssl.conf

```
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no

[req_distinguished_name]
CN = MyServerName

[v3_req]
subjectAltName = @alt_names

[alt_names]
IP.1 = 127.0.0.1
DNS.1 = MyServerName
DNS.2 = *.xxx.cn
```

ç”Ÿæˆ

```sh
openssl req -new -x509 -nodes -days 730 -keyout server.key -out server.crt -config openssl.conf
```

### CAç­¾å

[å‚è€ƒ](https://www.golinuxcloud.com/openssl-subject-alternative-name/)

```
[req]
distinguished_name = req_distinguished_name
req_extensions = req_ext
prompt = no

[req_distinguished_name]
CN = ums.xxx.cn

[req_ext]
subjectAltName = @alt_names

[alt_names]
IP.1 = 192.168.25.99
DNS.1 = ums.xxx.cn
DNS.2 = *.xxx.cn
```



```sh
# ç”Ÿæˆca
openssl req -newkey rsa:2048 -nodes -keyout ca.key -x509 -days 36500 -out ca.crt -subj "/C=xx/ST=x/L=x/O=x/OU=x/CN=ca/emailAddress=x/"

# ç»™ç”Ÿæˆçš„è¯ä¹¦CAç­¾å
openssl genrsa -out tls.key 2048
openssl req -new -key tls.key -out tls.csr -config openssl.conf
openssl x509 -req -days 36500 -in tls.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out tls.crt -extensions req_ext -extfile openssl.conf

# éªŒè¯SAN
openssl x509 -text -noout -in tls.crt | grep -A 1 "Subject Alternative Name"
```



## æŸ¥çœ‹è¯ä¹¦

```sh
# æŸ¥çœ‹KEYä¿¡æ¯
openssl rsa -noout -text -in myserver.key

# æŸ¥çœ‹CSRä¿¡æ¯
openssl req -noout -text -in myserver.csr

# æŸ¥çœ‹è¯ä¹¦ä¿¡æ¯
openssl x509 -noout -text -in ca.crt

# éªŒè¯è¯ä¹¦
openssl verify selfsign.crt

openssl verify -CAfile ca.crt myserver.crt
```



## HTTPS

### SSL è®¤è¯

- å•å‘SSLè®¤è¯ ä¸€èˆ¬clientæ¥æ ¡éªŒæœåŠ¡å™¨çš„åˆæ³•æ€§ã€‚

  - clientéœ€è¦ä¸€ä¸ªca.crt
  - severéœ€è¦server.crtã€server.key

  ```nginx
      listen       443 ssl;
      server_name  localhost;
  
      client_max_body_size 50M;
  
      ssl_certificate      /usr/local/nginx/ca/server/server.crt;
      ssl_certificate_key  /usr/local/nginx/ca/server/server.key;
  
      ssl_session_cache    shared:SSL:1m;
      ssl_session_timeout  5m;
  
      ssl_ciphers  HIGH:!aNULL:!MD5;
      ssl_prefer_server_ciphers  on;
  ```

  

- åŒå‘SSLè®¤è¯ æœåŠ¡å™¨éœ€è¦æ ¡éªŒæ¯ä¸ªclient, clientä¹Ÿéœ€è¦æ ¡éªŒæœåŠ¡å™¨ crtè¯ä¹¦ç”±ç­¾å

  - server éœ€è¦ server.key ã€server.crt ã€ca.crt
  - client éœ€è¦ client.key ã€client.crt ã€ca.crt

  ```nginx
   listen       443; 
   server_name  localhost; 
   ssi on; 
   ssi_silent_errors on; 
   ssi_types text/shtml; 
  
  ssl                  on; 
  ssl_certificate      /usr/local/nginx/ca/server/server.crt; 
  ssl_certificate_key  /usr/local/nginx/ca/server/server.key; 
  ssl_client_certificate /usr/local/nginx/ca/private/ca.crt; 
  
  ssl_session_timeout  5m; 
  ssl_verify_client on;  #å¼€æˆ·å®¢æˆ·ç«¯è¯ä¹¦éªŒè¯ 
  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDH:AES:HIGH:!aNULL:!MD5:!ADH:!DH;
  
  
  ssl_prefer_server_ciphers   on; 
  ```

  





### Hello é˜¶æ®µ

- Clientç«¯å‘é€httpsè¯·æ±‚

> 1. æ”¯æŒçš„åè®®ç‰ˆæœ¬
> 2. éšæœºæ•° **random1**ï¼Œç¨åç”¨äºç”Ÿæˆ"å¯¹è¯å¯†é’¥"ã€‚
> 3. æ”¯æŒçš„åŠ å¯†æ–¹æ³•ç­‰ä¿¡æ¯

- Serverç«¯

> 1. ç¡®è®¤ä½¿ç”¨çš„åŠ å¯†é€šä¿¡åè®®ç‰ˆæœ¬
> 2. å‘é€éšæœºæ•° **random2**ï¼Œç¨åç”¨äºç”Ÿæˆ"å¯¹è¯å¯†é’¥"ã€‚
> 3. ç¡®è®¤åŠ å¯†æ–¹æ³•ç­‰ä¿¡æ¯
> 4. å‘é€æ•°å­—è¯ä¹¦

### éªŒè¯æ•°å­—è¯ä¹¦

- **CAèº«ä»½éªŒè¯/è¿‡æœŸ CAæ ¹è¯ä¹¦éªŒè¯**: æµè§ˆå™¨å†…ç½®ä¸€ä¸ªå—ä¿¡ä»»çš„**CAæœºæ„åˆ—è¡¨**ï¼Œå¹¶ä¿å­˜äº†è¿™äº›CAæœºæ„çš„è¯ä¹¦ã€‚

- **Serverç«¯çš„æ•°å­—è¯ä¹¦ä¿¡æ¯ä¸å½“å‰æ­£åœ¨è®¿é—®çš„ç½‘ç«™ï¼ˆåŸŸåç­‰ï¼‰ä¸€è‡´**: Serverç«¯æ˜¯å¯ä¿¡çš„ -> **è·å¾—Serverå…¬é’¥**

> Clientç«¯æ˜¯å¦èƒ½å¤Ÿä¿¡ä»»è¿™ä¸ªç«™ç‚¹çš„è¯ä¹¦ï¼Œé¦–å…ˆå–å†³äºClientç«¯ç¨‹åºæ˜¯å¦å¯¼å…¥äº†è¯ä¹¦é¢å‘è€…çš„æ ¹è¯ä¹¦ã€‚**æŠ“åŒ…å·¥å…·è¦æŠ“httpsä¹Ÿè¦å¯¼å…¥å·¥å…·çš„è¯ä¹¦**



### åå•†é€šä¿¡å¯†é’¥
ä¼ è¾“å†…å®¹çš„åŠ å¯†æ˜¯é‡‡ç”¨çš„**å¯¹ç§°åŠ å¯†**ï¼Œå¯¹åŠ å¯†çš„å¯†é’¥ä½¿ç”¨å…¬é’¥è¿›è¡Œ**éå¯¹ç§°åŠ å¯†**

- Serverç«¯éªŒè¯å®¢æˆ·ç«¯(**optional**) å®¢æˆ·ç«¯çš„è¯ä¹¦ + éšæœºæ•°(Clientç«¯ç­¾å) = **å®¢æˆ·ç«¯èº«ä»½éªŒè¯**
- éªŒè¯é€šè¿‡åClientç«¯ç”Ÿæˆ éšæœºç (**PreMaster key**)**Serverå…¬é’¥**åŠ å¯† [+ **å®¢æˆ·ç«¯èº«ä»½éªŒè¯**] -> Serverç«¯

PreMaster key =   RSAæˆ–è€…Diffie-Hellmanç­‰åŠ å¯†ç®—æ³•ç”Ÿæˆ

>PreMaster keyæ˜¯åœ¨å®¢æˆ·ç«¯ä½¿ç”¨RSAæˆ–è€…Diffie-Hellmanç­‰åŠ å¯†ç®—æ³•ç”Ÿæˆçš„ã€‚
>
>PreMaster keyå‰ä¸¤ä¸ªå­—èŠ‚æ˜¯TLSçš„ç‰ˆæœ¬å·ï¼Œè¿™æ˜¯ä¸€ä¸ª**æ¯”è¾ƒé‡è¦çš„ç”¨æ¥æ ¸å¯¹æ¡æ‰‹æ•°æ®çš„ç‰ˆæœ¬å·**ï¼Œå› ä¸ºåœ¨Client Helloé˜¶æ®µï¼Œ
>å®¢æˆ·ç«¯ä¼šå‘é€ä¸€ä»½åŠ å¯†å¥—ä»¶åˆ—è¡¨å’Œå½“å‰æ”¯æŒçš„SSL/TLSçš„ç‰ˆæœ¬å·ç»™æœåŠ¡ç«¯ï¼Œè€Œä¸”æ˜¯ä½¿ç”¨æ˜æ–‡ä¼ é€çš„ï¼Œ
>å¦‚æœæ¡æ‰‹çš„æ•°æ®åŒ…è¢«ç ´è§£ä¹‹åï¼Œæ”»å‡»è€…å¾ˆæœ‰å¯èƒ½ä¸²æ”¹æ•°æ®åŒ…ï¼Œé€‰æ‹©ä¸€ä¸ªå®‰å…¨æ€§è¾ƒä½çš„åŠ å¯†å¥—ä»¶å’Œç‰ˆæœ¬ç»™æœåŠ¡ç«¯ï¼Œä»è€Œå¯¹æ•°æ®è¿›è¡Œç ´è§£ã€‚
>æ‰€ä»¥ï¼ŒæœåŠ¡ç«¯éœ€è¦å¯¹å¯†æ–‡ä¸­è§£å¯†å‡ºæ¥å¯¹çš„PreMasterç‰ˆæœ¬å·è·Ÿä¹‹å‰Client Helloé˜¶æ®µçš„ç‰ˆæœ¬å·è¿›è¡Œå¯¹æ¯”ï¼Œ
>å¦‚æœç‰ˆæœ¬å·å˜ä½ï¼Œåˆ™è¯´æ˜è¢«ä¸²æ”¹ï¼Œåˆ™ç«‹å³åœæ­¢å‘é€ä»»ä½•æ¶ˆæ¯ã€‚

- Serverç«¯éªŒè¯ **å®¢æˆ·ç«¯èº«ä»½**(**optional**)è¿‡åï¼Œè§£å¯†å¾—åˆ°**PreMaster key** 
- åŒç«¯ç”Ÿæˆ**Master key** = ä¸€ç³»åˆ—ç®—æ³•(**PreMaster key** + **random1** +  **random2**)

- åŒç«¯ï¼šå‘é€**ChangeCipherSpecåè®®**ï¼Œæ•°æ®åŒ…ä¸­å°±æ˜¯ä¸€ä¸ªå­—èŠ‚çš„æ•°æ®ï¼Œç”¨äºå‘ŠçŸ¥æœåŠ¡ç«¯ï¼Œå®¢æˆ·ç«¯å·²ç»**åˆ‡æ¢åˆ°ä¹‹å‰åå•†å¥½çš„åŠ å¯†å¥—ä»¶**ï¼ˆCipher Suiteï¼‰çš„çŠ¶æ€ï¼Œå‡†å¤‡ä½¿ç”¨ä¹‹å‰åå•†å¥½çš„åŠ å¯†å¥—ä»¶åŠ å¯†æ•°æ®å¹¶ä¼ è¾“äº†ã€‚
- åŒç«¯ï¼šåå•†å¥½çš„åŠ å¯†å¥—ä»¶å’ŒSession SecretåŠ å¯†ä¸€æ®µ **Finish** çš„æ•°æ®ä¼ é€ç»™æœåŠ¡ç«¯ï¼Œæ­¤æ•°æ®æ˜¯ä¸ºäº†åœ¨æ­£å¼ä¼ è¾“åº”ç”¨æ•°æ®ä¹‹å‰å¯¹åˆšåˆšæ¡æ‰‹å»ºç«‹èµ·æ¥çš„åŠ è§£å¯†é€šé“è¿›è¡ŒéªŒè¯ã€‚


> å¦‚æœ**PreMaster key**æ³„æ¼ å®Œè›‹äº†

### é€šä¿¡è¿‡ç¨‹

S: åŠ å¯†(æ¶ˆæ¯+æ¶ˆæ¯æ‘˜è¦) R: è§£å¯† å¯¹æ¯”æ‘˜è¦



# hash å¯†ç 

[å¼•ç”¨ hashing-security](https://crackstation.net/hashing-security.htm)


ä¿æŠ¤å¯†ç çš„æœ€å¥½åŠæ³•æ˜¯ä½¿ç”¨åŠ ç›å¯†ç å“ˆå¸Œ**salted password hashing**

æ”¾å¼ƒç¼–å†™è‡ªå·±çš„å¯†ç å“ˆå¸ŒåŠ å¯†ä»£ç çš„å¿µå¤´ï¼Œè¦ä½¿ç”¨æˆç†Ÿæ–¹æ¡ˆã€‚


## hash what

å“ˆå¸Œç®—æ³•æ•£åˆ—ç®—æ³•æ˜¯å•å‘å‡½æ•°ã€‚ä»–ä»¬å°†ä»»æ„æ•°é‡çš„æ•°æ®è½¬æ¢ä¸ºå›ºå®šé•¿åº¦çš„**æŒ‡çº¹**ï¼Œæ— æ³•é€†è½¬ã€‚


## ç ´è§£hash


- å­—å…¸æ”»å‡» Dictionary

> å­—å…¸æ”»å‡»ä½¿ç”¨åŒ…å«å•è¯ï¼ŒçŸ­è¯­ï¼Œå…¬å…±å¯†ç å’Œå…¶ä»–å¯èƒ½ç”¨ä½œå¯†ç çš„å­—ç¬¦ä¸²çš„æ–‡ä»¶ã€‚å¯¹æ–‡ä»¶ä¸­çš„æ¯ä¸ªå•è¯è¿›è¡Œå“ˆå¸Œå¤„ç†ï¼Œå¹¶å°†å…¶å“ˆå¸Œå€¼ä¸å¯†ç å“ˆå¸Œå€¼è¿›è¡Œæ¯”è¾ƒã€‚

-  æš´åŠ›æ”»å‡» Brute Force Attacks

> å¯¹äºç»™å®šçš„å¯†ç é•¿åº¦ï¼Œå°è¯•æ¯ä¸€ç§å¯èƒ½çš„å­—ç¬¦ç»„åˆã€‚è¿™ç§æ–¹å¼ä¼šæ¶ˆè€—å¤§é‡çš„è®¡ç®—ï¼Œä¹Ÿæ˜¯ç ´è§£å“ˆå¸ŒåŠ å¯†æ•ˆç‡æœ€ä½çš„åŠæ³•ï¼Œä½†æœ€ç»ˆä¼šæ‰¾å‡ºæ­£ç¡®çš„å¯†ç ã€‚å› æ­¤å¯†ç åº”è¯¥è¶³å¤Ÿé•¿ï¼Œä»¥è‡³äºéå†æ‰€æœ‰å¯èƒ½çš„å­—ç¬¦ç»„åˆï¼Œè€—è´¹çš„æ—¶é—´å¤ªé•¿ä»¤äººæ— æ³•æ‰¿å—ï¼Œä»è€Œæ”¾å¼ƒç ´è§£ã€‚


- æŸ¥è¡¨æ³•ï¼ˆ Lookup Tablesï¼‰

> æŸ¥æ‰¾è¡¨æ˜¯ä¸€ç§éå¸¸æœ‰æ•ˆçš„æ–¹æ³•ï¼Œå¯ä»¥éå¸¸å¿«é€Ÿåœ°ç ´è§£ç›¸åŒç±»å‹çš„å¤šä¸ªå“ˆå¸Œå€¼ã€‚ä¸€èˆ¬çš„æƒ³æ³•æ˜¯åœ¨å¯†ç å­—å…¸ä¸­**é¢„å…ˆè®¡ç®—å¯†ç **çš„å“ˆå¸Œå€¼ï¼Œå¹¶å°†å®ƒä»¬åŠå…¶ç›¸åº”çš„å¯†ç å­˜å‚¨åœ¨æŸ¥æ‰¾è¡¨æ•°æ®ç»“æ„ä¸­ã€‚æŸ¥æ‰¾è¡¨çš„è‰¯å¥½å®ç°æ¯ç§’å¯ä»¥å¤„ç†æ•°ç™¾ä¸ªå“ˆå¸ŒæŸ¥æ‰¾ï¼Œå³ä½¿å®ƒä»¬åŒ…å«æ•°åäº¿ä¸ªå“ˆå¸Œå€¼

- åå‘æŸ¥è¡¨æ³•ï¼ˆ Reverse Lookup Tablesï¼‰

> è¿™ç§æ”»å‡»å…è®¸æ”»å‡»è€…æ— éœ€é¢„å…ˆè®¡ç®—å¥½æŸ¥è¯¢è¡¨çš„æƒ…å†µä¸‹åŒæ—¶å¯¹å¤šä¸ªå“ˆå¸Œå€¼å‘èµ·å­—å…¸æ”»å‡»æˆ–æš´åŠ›æ”»å‡»ã€‚
> é¦–å…ˆï¼Œæ”»å‡»è€…ä»è¢«é»‘çš„ç”¨æˆ·å¸å·æ•°æ®åº“åˆ›å»ºä¸€ä¸ªç”¨æˆ·åå’Œå¯¹åº”çš„å¯†ç å“ˆå¸Œè¡¨ï¼Œç„¶åï¼Œæ”»å‡»è€…çŒœæµ‹ä¸€ç³»åˆ—å“ˆå¸Œå€¼å¹¶ä½¿ç”¨è¯¥æŸ¥è¯¢è¡¨æ¥æŸ¥æ‰¾ä½¿ç”¨æ­¤å¯†ç çš„ç”¨æˆ·ã€‚é€šå¸¸è®¸å¤šç”¨æˆ·éƒ½ä¼šä½¿ç”¨ç›¸åŒçš„å¯†ç ï¼Œå› æ­¤è¿™ç§æ”»å‡»æ–¹å¼ç‰¹åˆ«æœ‰æ•ˆã€‚

- å½©è™¹è¡¨ï¼ˆ Rainbow Tablesï¼‰

> ä¸æŸ¥è¡¨æ³•ç›¸ä¼¼ï¼Œåªæ˜¯å®ƒä¸ºäº†ä½¿æŸ¥è¯¢è¡¨æ›´å°ï¼Œç‰ºç‰²äº†ç ´è§£é€Ÿåº¦ã€‚å› ä¸ºå½©è™¹è¡¨æ›´å°ï¼Œæ‰€ä»¥åœ¨å•ä½ç©ºé—´å¯ä»¥å­˜å‚¨æ›´å¤šçš„å“ˆå¸Œå€¼ï¼Œä»è€Œä½¿æ”»å‡»æ›´æœ‰æ•ˆã€‚


## salt

æŸ¥æ‰¾è¡¨å’Œå½©è™¹è¡¨èµ·ä½œç”¨ï¼Œå› ä¸ºæ¯ä¸ªå¯†ç éƒ½ä»¥å®Œå…¨ç›¸åŒçš„æ–¹å¼è¿›è¡Œå“ˆå¸Œå¤„ç†ã€‚ç›¸åŒçš„å¯†ç æœ‰ç›¸åŒçš„å¯†ç å“ˆå¸Œå€¼

å¯†ç ä¸­åŠ å…¥ä¸€æ®µéšæœºå­—ç¬¦ä¸²å†è¿›è¡Œå“ˆå¸ŒåŠ å¯†ï¼Œè¿™ä¸ªè¢«åŠ çš„å­—ç¬¦ä¸²ç§°ä¹‹ä¸º**ç›**ï¼Œä½¿å¾—ç›¸åŒçš„å¯†ç æ¯æ¬¡éƒ½è¢«åŠ å¯†ä¸ºå®Œå…¨ä¸åŒçš„å­—ç¬¦ä¸²ã€‚

æˆ‘ä»¬éœ€è¦ç›å€¼æ¥æ ¡éªŒå¯†ç æ˜¯å¦æ­£ç¡®ã€‚é€šå¸¸å’Œå¯†ç å“ˆå¸Œå€¼ä¸€åŒå­˜å‚¨åœ¨å¸å·æ•°æ®åº“ä¸­ï¼Œæˆ–è€…ä½œä¸ºå“ˆå¸Œå­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†ã€‚
ç›å€¼æ— éœ€åŠ å¯†ã€‚ç”±äºéšæœºåŒ–äº†å“ˆå¸Œå€¼ï¼ŒæŸ¥è¡¨æ³•ã€åå‘æŸ¥è¡¨æ³•å’Œå½©è™¹è¡¨éƒ½ä¼šå¤±æ•ˆã€‚


### é”™è¯¯ç”¨æ³•

- ç›å€¼å¤ç”¨ï¼ˆ Salt Reuseï¼‰

> ç›¸åŒçš„å¯†ç ï¼Œä»–ä»¬ä»ç„¶ä¼šæœ‰ç›¸åŒçš„å“ˆå¸Œå€¼ã€‚æ”»å‡»è€…ä»ç„¶å¯ä»¥ä½¿ç”¨åå‘æŸ¥è¡¨æ³•å¯¹æ¯ä¸ªå“ˆå¸Œå€¼è¿›è¡Œå­—å…¸æ”»å‡» **æ¯æ¬¡ç”¨æˆ·åˆ›å»ºå¸æˆ·æˆ–æ›´æ”¹å¯†ç æ—¶ï¼Œéƒ½å¿…é¡»ç”Ÿæˆæ–°çš„éšæœºç›**

- çŸ­ç›å€¼ï¼ˆ Short Slatï¼‰

> æ”»å‡»è€…å¯ä»¥ä¸ºæ¯ç§å¯èƒ½çš„ç›æ„å»ºæŸ¥æ‰¾è¡¨ ä¸ºäº†ä½¿æ”»å‡»è€…æ— æ³•ä¸ºæ¯ä¸ªå¯èƒ½çš„ç›åˆ›å»ºæŸ¥æ‰¾è¡¨ï¼Œç›å¿…é¡»å¾ˆé•¿ã€‚ä¸€ä¸ªå¥½çš„ç»éªŒæ³•åˆ™æ˜¯ä½¿ç”¨ä¸æ•£åˆ—å‡½æ•°è¾“å‡ºå¤§å°ç›¸åŒçš„saltã€‚ä¾‹å¦‚ï¼ŒSHA256çš„è¾“å‡ºæ˜¯256ä½ï¼ˆ32å­—èŠ‚ï¼‰ï¼Œå› æ­¤saltåº”è‡³å°‘ä¸º32ä¸ªéšæœºå­—èŠ‚

- å¤æ€ªå“ˆå¸Œçš„ç®—æ³•ç»„åˆ

> å°è¯•ä¸åŒçš„å“ˆå¸Œå‡½æ•°ç›¸ç»“åˆä¸€èµ·ä½¿ç”¨ï¼Œå¸Œæœ›è®©æ•°æ®ä¼šæ›´å®‰å…¨ã€‚ä½†åœ¨å®è·µä¸­ï¼Œè¿™æ ·åšå¹¶æ²¡æœ‰ä»€ä¹ˆå¥½å¤„ã€‚
> å®ƒå¸¦æ¥äº†å‡½æ•°ä¹‹é—´äº’é€šæ€§çš„é—®é¢˜ï¼Œè€Œä¸”ç”šè‡³å¯èƒ½ä¼šä½¿å“ˆå¸Œå˜å¾—æ›´ä¸å®‰å…¨ã€‚**æ°¸è¿œä¸è¦è¯•å›¾å»åˆ›é€ ä½ è‡ªå·±çš„å“ˆå¸ŒåŠ å¯†ç®—æ³•ï¼Œè¦ä½¿ç”¨ä¸“å®¶è®¾è®¡å¥½çš„æ ‡å‡†ç®—æ³•ã€‚**

å½“æ”»å‡»è€…ä¸çŸ¥é“å“ˆå¸ŒåŠ å¯†ç®—æ³•çš„æ—¶å€™ï¼Œæ˜¯æ— æ³•å‘èµ·æ”»å‡»çš„ã€‚ä½†æ˜¯è¦è€ƒè™‘åˆ°[Kerckhoffsçš„åŸåˆ™](https://en.wikipedia.org/wiki/Kerckhoffs%27s_principle)ï¼Œæ”»å‡»è€…é€šå¸¸ä¼šè·å¾—æºä»£ç ï¼ˆå°¤å…¶æ˜¯å…è´¹æˆ–è€…å¼€æºè½¯ä»¶ï¼‰ã€‚é€šè¿‡ç³»ç»Ÿä¸­æ‰¾å‡ºå¯†ç  - å“ˆå¸Œå€¼å¯¹åº”å…³ç³»ï¼Œå¾ˆå®¹æ˜“åå‘æ¨å¯¼å‡ºåŠ å¯†ç®—æ³•ã€‚

### æ­£ç¡®åšæ³•

- åŠ ç›
- Webåº”ç”¨ä¸­æ°¸è¿œåœ¨æœåŠ¡ç«¯ä¸Šè¿›è¡Œå“ˆå¸ŒåŠ å¯†
- æ…¢å“ˆå¸Œå‡½æ•°ï¼ˆ Slow Hash Functionï¼‰

ä¸ºäº†é™ä½ä½¿è¿™äº›æ”»å‡»çš„æ•ˆç‡ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªå«åšå¯†é’¥æ‰©å±•ï¼ˆ key stretchingï¼‰çš„æŠ€æœ¯ã€‚å¯†é’¥æ‰©å±•çš„å®ç°ä½¿ç”¨äº†ä¸€ç§ CPU å¯†é›†å‹å“ˆå¸Œå‡½æ•°ï¼ˆ CPU-intensive hash functionï¼‰

> è¿™ç±»ç®—æ³•é‡‡å–å®‰å…¨å› å­æˆ–è¿­ä»£æ¬¡æ•°ä½œä¸ºå‚æ•°ã€‚æ­¤å€¼å†³å®šå“ˆå¸Œå‡½æ•°å°†ä¼šå¦‚ä½•ç¼“æ…¢ã€‚å¯¹äºæ¡Œé¢è½¯ä»¶æˆ–æ™ºèƒ½æ‰‹æœºåº”ç”¨ï¼Œ
> ç¡®å®šè¿™ä¸ªå‚æ•°çš„æœ€ä½³æ–¹å¼æ˜¯åœ¨è®¾å¤‡ä¸Šè¿è¡Œå¾ˆçŸ­çš„æ€§èƒ½åŸºå‡†æµ‹è¯•ï¼Œæ‰¾åˆ°ä½¿å“ˆå¸Œå¤§çº¦èŠ±è´¹åŠç§’çš„å€¼ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œç¨‹åºå¯ä»¥å°½å¯èƒ½ä¿è¯å®‰å…¨è€Œåˆä¸å½±å“ç”¨æˆ·ä½“éªŒã€‚

ç¼ºç‚¹

> éœ€è¦é¢å¤–çš„è®¡ç®—èµ„æºæ¥å¤„ç†å¤§é‡çš„èº«ä»½è®¤è¯è¯·æ±‚ï¼Œå¹¶ä¸”å¯†é’¥æ‰©å±•ä¹Ÿå®¹æ˜“è®©æœåŠ¡ç«¯é­å—DDoS

- åŠ å¯†hash  ASEç®—æ³•å¯¹å“ˆå¸Œå€¼åŠ å¯† å¯†é’¥å¿…é¡»è¢«å­˜å‚¨åœ¨å¤–éƒ¨ç³»ç»Ÿ

# code
```python
def to_bytes(bytes_or_str):
    if isinstance(bytes_or_str, str):
        return bytes_or_str.encode()
    return bytes_or_str


def to_str(bytes_or_str):
    if isinstance(bytes_or_str, bytes):
        return bytes_or_str.decode()
    return bytes_or_str
```
## base64
```python
def t_b64():
    import base64
    def encode(raw):
        """
        äºŒè¿›åˆ¶æ•°æ®è¿›è¡ŒBase64ç¼–ç 

        å°†éASCIIå­—ç¬¦çš„æ•°æ®è½¬æ¢æˆASCIIå­—ç¬¦çš„ä¸€ç§æ–¹æ³• å¯¹æ•°æ®å†…å®¹è¿›è¡Œç¼–ç æ¥é€‚åˆä¼ è¾“ã€ä¿å­˜ï¼Œe.g asciiç æœ‰äº›å€¼ä¸å¯è§

        æ ¹è¯ä¹¦ï¼Œemailé™„ä»¶ Base64ç¼–ç å›¾ç‰‡
        """
        return base64.b64encode(to_bytes(raw))

    def decode(raw_b):
        return to_str(base64.b64decode(raw_b))

    encode_b = encode('fafafä¸ªæŠŠä¸ªå…³')
    print(encode_b)  # b'ZmFmYWbkuKrmiorkuKrlhbM='
    print(decode(encode_b))  # fafafä¸ªæŠŠä¸ªå…³


def gen_user_token(login_type: int) -> str:
    raw = get_random_bytes(USER_TOKEN_BITS) + struct.pack('>L', int(time.time()))
    return safe_base64_encode(raw).decode()


def rand_byte2b64(bits: int) -> bytes:
    return base64.urlsafe_b64encode(gen_random_key(bits))


def safe_base64_encode(s: bytes, encode_func: typing.Callable = base64.urlsafe_b64encode) -> bytes:
    # cookie ä¸æ”¯æŒ =
    return encode_func(s).replace(b'=', b'')


def safe_base64_decode(s: bytes, decode_func: typing.Callable = base64.urlsafe_b64decode) -> bytes:
    s += b'==='
    b = s[:-1 * (len(s) % 4)]
    return decode_func(b)


```

## hash
```python
def t_hmac():
    import hmac
    import hashlib

    def encode(secret_key, payload):
        """
        åŠ å¯†ç”¨çš„æ•£åˆ—å‡½æ•° 64ä½  md5ã€sha3 æ¶ˆæ¯æ— é™å¤§
        """
        # return hmac.new(to_bytes(secret_key), to_bytes(payload), digestmod=hashlib.sha256).digest()
        return hmac.new(to_bytes(secret_key), to_bytes(payload), digestmod=hashlib.sha256).hexdigest()

    signature = encode('21a1f34d2c785f296c90ba54ead31d98e5c1838351cdfea0434c9edfcd1a0252', 'woæˆ‘æ˜¯msg')
    print(signature)


def t_md5():
    import hashlib

    def encode(payload):
        """
        32 ä½ hashå‡½æ•°
        """
        # return hashlib.md5(to_bytes(payload)).digest()
        return hashlib.md5(to_bytes(payload)).hexdigest()

    print(encode('woæˆ‘æ˜¯msgfafafdfdfadfafafafafafa'))


# pysodium hash

ENCODED_PASSWORD_BYTES = pysodium.crypto_auth_KEYBYTES + pysodium.crypto_pwhash_SALTBYTES
def _crypto_hash(password: str, salt: bytes) -> bytes:
    return pysodium.crypto_pwhash(pysodium.crypto_auth_KEYBYTES, password, salt,
                                  pysodium.crypto_pwhash_argon2id_OPSLIMIT_INTERACTIVE,
                                  pysodium.crypto_pwhash_argon2id_MEMLIMIT_INTERACTIVE,
                                  pysodium.crypto_pwhash_ALG_ARGON2ID13)

def encode_password(password) -> bytes:
    salt = _generate_salt()
    password_hash = _crypto_hash(password, salt)
    return password_hash + salt


def verify_password(password, encoded_password) -> bool:
    if len(encoded_password) != ENCODED_PASSWORD_BYTES:
        return False
    password_hash = encoded_password[:pysodium.crypto_auth_KEYBYTES]
    salt = encoded_password[-pysodium.crypto_pwhash_SALTBYTES:]
    return _crypto_hash(password, salt) == password_hash


```
[pycryptodome](https://github.com/Legrandin/pycryptodome)

## RSA
```python
def t_RSA(msg, passwd=None):
    from Crypto.PublicKey import RSA
    from Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5
    from Crypto.Signature import PKCS1_v1_5 as Signature_pkcs1_v1_5
    from Crypto.Hash import SHA256

    def generate(bits=2048, passwd=None, path='id_rsa', ):
        key = RSA.generate(bits)
        private_key = key.export_key(passphrase=passwd)

        with open(path + '.pub', "wb")as pub:
            pub.write(key.publickey().export_key())

        with open(path, "wb")as pub:
            pub.write(private_key)

    def encrypt(msg, passwd=None, path='id_rsa'):
        """å…¬é’¥åŠ å¯†"""
        msg = to_bytes(msg)
        key = RSA.import_key(open(path + '.pub').read(), passphrase=passwd)

        cipher = Cipher_pkcs1_v1_5.new(key)
        result = cipher.encrypt(msg)
        return result

    def decrypt(encrypt_txt, passwd=None, path='id_rsa'):
        key = RSA.import_key(open(path).read(), passphrase=passwd)

        cipher = Cipher_pkcs1_v1_5.new(key)
        result = cipher.decrypt(encrypt_txt, None)
        return result

    def sign(msg, passwd=None, path='id_rsa'):
        msg = to_bytes(msg)
        key = RSA.import_key(open(path).read(), passphrase=passwd)
        signer = Signature_pkcs1_v1_5.new(key)
        digest = SHA256.new(msg)
        signature = signer.sign(digest)
        return signature

    def check_sign(msg, sign, passwd=None, path='id_rsa'):
        msg = to_bytes(msg)
        key = RSA.import_key(open(path + '.pub').read(), passphrase=passwd)
        signer = Signature_pkcs1_v1_5.new(key)
        digest = SHA256.new(msg)
        assert signer.verify(digest, sign) is True

    generate(passwd=passwd)
    result = decrypt(encrypt(msg), passwd)
    assert msg == to_str(result)
    signature = sign(msg, passwd)
    check_sign(msg, signature)
```

## AES
```python
def t_AES(msg, passwd):
    from Crypto.Cipher import AES
    from Crypto import Random
    import hashlib
    import base64

    BS = AES.block_size
    """
    padå’Œunpadåˆ†åˆ«æ˜¯å¡«å……å‡½æ•°å’Œé€†å¡«å……å‡½æ•° 
    æ–‡æœ¬é•¿åº¦æ­£å¥½æ˜¯BlockSizeé•¿åº¦çš„å€æ•°ï¼Œä¹Ÿä¼šå¡«å……ä¸€ä¸ªBlockSizeé•¿åº¦çš„å€¼
    ç¼ºå‡ ä½å°±è¡¥å‡  è¦å¡«å……8ä¸ªå­—èŠ‚,é‚£ä¹ˆå¡«å……çš„å­—èŠ‚çš„å€¼å°±æ˜¯0x08
    
    AESåŠ å¯†å¯¹åŠ å¯†æ–‡æœ¬æœ‰é•¿åº¦è¦æ±‚
    å¿…é¡»æ˜¯AES.block_sizeçš„æ•´å€æ•°
    
    """
    pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)
    unpad = lambda s: s[:-ord(s[len(s) - 1:])]
    """
    å®é™…ä¸ŠAESåŠ å¯†æœ‰AES-128ã€AES-192ã€AES-256ä¸‰ç§ï¼Œ
    åˆ†åˆ«å¯¹åº”ä¸‰ç§å¯†é’¥é•¿åº¦128bitsï¼ˆ16å­—èŠ‚ï¼‰ã€192bitsï¼ˆ24å­—èŠ‚ï¼‰ã€256bitsï¼ˆ32å­—èŠ‚ï¼‰ã€‚
    å½“ç„¶ï¼Œå¯†é’¥è¶Šé•¿ï¼Œå®‰å…¨æ€§è¶Šé«˜ï¼ŒåŠ è§£å¯†èŠ±è´¹æ—¶é—´ä¹Ÿè¶Šé•¿ã€‚
    """
    passwd = hashlib.sha256(to_bytes(passwd)).digest()

    def encrypt(msg):
        msg = to_bytes(pad(msg))
        iv = Random.new().read(BS)
        cipher = AES.new(passwd, mode=AES.MODE_CBC, iv=iv)
        result = cipher.encrypt(msg)
        return base64.b64encode(iv + result)

    def decrypt(encrypt_txt):
        encrypt_txt = base64.b64decode(encrypt_txt)
        iv = encrypt_txt[:BS]
        cipher = AES.new(passwd, mode=AES.MODE_CBC, iv=iv)
        result = unpad(cipher.decrypt(encrypt_txt[BS:]))
        return result

    result = decrypt(encrypt(msg))
    assert msg == to_str(result)
```

## å®Œå–„ç‰ˆ

### python åŠ å¯†è§£å¯†

```python
def sign(private_key, data: bytes) -> bytes:
    h = SHA256.new(data)
    return pkcs1_15.new(private_key).sign(h)


def verify_sign(pub_key, data, signature) -> bool:
    h = SHA256.new(data)
    try:
        pkcs1_15.new(pub_key).verify(h, signature)
    except (ValueError, TypeError):
        raise False
    return True


def aes_encrypt(aes_key: bytes, data: bytes) -> bytes:
    cipher = AES.new(aes_key, AES.MODE_CBC)
    ct = cipher.encrypt(pad(data, AES.block_size))
    return cipher.iv + ct


def aes_decrypt(aes_key: bytes, data: bytes) -> bytes:
    iv, ct = data[:AES.block_size], data[AES.block_size:]  # ç¡®è®¤ iv æœªè¢«ä½¿ç”¨
    cipher = AES.new(aes_key, AES.MODE_CBC, iv)
    return unpad(cipher.decrypt(ct), AES.block_size)


def encrypt_license(data: typing.Union[dict, list], aes_key: bytes, schema: dict = LICENSE_SCHEMA) -> bytes:
    data = avro_encode(data, schema)
    private_key = SERVER_PRIVATE_KEY
    # hash ç­¾å
    signature = sign(private_key, data)
    signed_data = data + signature
    # aes åŠ å¯†
    license_data = aes_encrypt(aes_key, signed_data)
    return license_data


def decrypt_license(license_data: bytes, aes_key: bytes, schema: dict = LICENSE_SCHEMA) -> typing.Optional[typing.Union[dict, list]]:
    pub_key = CLIENT_PUB_KEY
    # aes è§£å¯†
    data = aes_decrypt(aes_key, license_data)
    # éªŒè¯ç­¾å
    data, signature = data[:-512], data[-512:]
    if not verify_sign(pub_key, data, signature):
        return None
    data = avro_decode(data, schema)
    return data


def gen_rsa_keys():
    """ç”Ÿæˆå¹¶è¿”å›ç§é’¥å’Œå…¬é’¥"""
    key = RSA.generate(4096)
    private_key = key
    pub_key = key.publickey()
    return private_key, pub_key


def init_rsa_keys():
    global SERVER_PRIVATE_KEY, CLIENT_PUB_KEY, CLIENT_PRIVATE_KEY, SERVER_PUB_KEY

    def init_key(private_path, pub_path):
        if os.path.exists(private_path) and os.path.exists(pub_path):
            with open(private_path) as f:
                private_key = f.read()
            private_key = RSA.import_key(private_key)

            with open(pub_path) as f:
                pub_key = f.read()
            pub_key = RSA.import_key(pub_key)
            return private_key, pub_key

        private_key, pub_key = gen_rsa_keys()
        with open(private_path, 'wb') as f:
            f.write(private_key.export_key())

        with open(pub_path, 'wb') as f:
            f.write(pub_key.export_key())

        return private_key, pub_key

    SERVER_PRIVATE_KEY, CLIENT_PUB_KEY = init_key(_SERVER_PRIVATE_KEY_PATH, _CLIENT_PUB_KEY_PATH)
    CLIENT_PRIVATE_KEY, SERVER_PUB_KEY = init_key(_CLIENT_PRIVATE_KEY_PATH, _SERVER_PUB_KEY_PATH)

# AES key
def gen_random_key(bits: int) -> bytes:
    return get_random_bytes(bits)

```



### golang åŠ å¯†è§£å¯†

```go
func pkcs7Unpadding(data []byte) []byte {
	pDataLen := len(data)
	paddingLen := int(data[pDataLen-1])
	return data[:(pDataLen - paddingLen)]
}

func pkcs7Padding(data []byte, blockSize int) []byte {
	padding := blockSize - len(data)%blockSize
	padtext := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(data, padtext...)
}
func aesEncrypt(aesKey []byte, data []byte) (cipherText []byte, err error) {
	block, err := aes.NewCipher(aesKey)
	if err != nil {
		fmt.Println(err)
		return
	}
	blockSize := block.BlockSize()
	data = pkcs7Padding(data, blockSize)
	cipherText = make([]byte, blockSize+len(data))
	iv := cipherText[:blockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		panic(err)
	}
	mode := cipher.NewCBCEncrypter(block, iv)
	mode.CryptBlocks(cipherText[blockSize:], data)
	return
}
func aesDecrypt(aesKey []byte, data []byte) (b []byte, err error) {
	block, err := aes.NewCipher(aesKey)
	if err != nil {
		fmt.Println(err)
		return
	}
	iv, ct := data[:block.BlockSize()], data[block.BlockSize():]
	blockMode := cipher.NewCBCDecrypter(block, iv)
	origData := make([]byte, len(ct))
	blockMode.CryptBlocks(origData, ct)
	b = pkcs7Unpadding(origData)
	return
}

func getPubKey() (pubKey *rsa.PublicKey) {
	pub, _ := ioutil.ReadFile("client.pub")
	block, _ := pem.Decode(pub)
	parsedKey, _ := x509.ParsePKIXPublicKey(block.Bytes)
	pubKey = parsedKey.(*rsa.PublicKey)
	return
}
func getPrivateKey() (privateKey *rsa.PrivateKey) {
	private, err := ioutil.ReadFile("client")
	if err != nil {
		fmt.Println(err)
		return
	}
	pubPem, _ := pem.Decode(private)
	privateKey, _ = x509.ParsePKCS1PrivateKey(pubPem.Bytes)
	return
}

func sign(data []byte) (s []byte) {
	privateKey := getPrivateKey()
	h := sha256.New()
	h.Write(data)
	s, _ = rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, h.Sum(nil))
	return
}

func verifySign(data []byte, signature []byte) bool {
	hash := sha256.New()
	hash.Write(data)
	pubKey := getPubKey()
	err := rsa.VerifyPKCS1v15(pubKey, crypto.SHA256, hash.Sum(nil), signature)
	if err != nil {
		return false
	}
	return true
}

func DecryptLicense(licenseData []byte, aesKey []byte, schema string) (t map[string]interface{}, err error) {
	// aes è§£å¯†
	origData, err := aesDecrypt(aesKey, licenseData)
	if err != nil {
		fmt.Println(err)
		return
	}
	// ç­¾åéªŒè¯
	origDataLen := len(origData)
	data, signature := origData[:origDataLen-512], origData[origDataLen-512:]
	ok := verifySign(data, signature)
	if ok == false {
		fmt.Println("sign verify fail")
		return nil, errors.New("sign verify fail")
	}

	license, err := avroDecode(data, schema)
	if err != nil {
		fmt.Println(err)
		return nil, errors.New("avro decode fail")
	}
	t, _ = license.(map[string]interface{})

	return
}

func EncryptLicense(licenseData interface{}, aesKey []byte, schema string) (license []byte, err error) {
	data, err := avroEncode(licenseData, schema)
	if err != nil {
		fmt.Println(err)
		return
	}
	buffer := bytes.Buffer{}
	buffer.Write(data)
	signature := sign(data)
	buffer.Write(signature)

	license, err = aesEncrypt(aesKey, buffer.Bytes())
	if err != nil {
		fmt.Println(err)
		return
	}
	return
}

```