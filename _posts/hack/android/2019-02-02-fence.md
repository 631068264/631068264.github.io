---
layout:     post
rewards: false
title:     fence 防护机制
categories:
    - hack
tags:
    - android hack
---

# 混淆
安全防护 减小包大小

### 代码混淆
- classes.dex + dex2jar -> jar-> jd-gui
- apktool -> smali
![](https://ws2.sinaimg.cn/large/006tNc79gy1fzrxpbgmq2j31o00u0k64.jpg)

### 资源混淆
[AndResGuard](https://github.com/shwenzhang/AndResGuard)

类似Java Proguard，但是只针对资源，将原本冗长的资源路径变短
![](https://ws4.sinaimg.cn/large/006tNc79gy1fzry4oss5mj31e60u04dd.jpg)

# 签名

没有签名apk不能安装，每个app都有一个**唯一**签名。同一包名不同签名不允许。

debug有个默认签名文件进行签名。

为了防止二次打包，检查签名。<span class='heimu'>都二次打包改代码了，干掉检查很难？</span>
![](https://ws4.sinaimg.cn/large/006tNc79gy1fzrym19vesj315w0u0tlh.jpg)
![](https://ws3.sinaimg.cn/large/006tNc79gy1fzrymytc1lj31sc0r0n4z.jpg)

### APK签名机制

#### 数字签名
- 确保消息来源
- 确保消息不被篡改

S : 发送者
R : 接收者


$$ S\xrightarrow{\mathrm{公钥}}R $$

$$ S\xrightarrow{\mathrm{原始消息}\;+\;\mathrm{私钥加密}(\mathrm{消息摘要})\;}R $$

$$ R\;\left\{\begin{array}{l}\mathrm{原始消息}\;\xrightarrow[{}]{}\mathrm{摘要}A\\\mathrm{加密摘要}\xrightarrow[\mathrm{公钥解密}]{}\mathrm{摘要}B\end{array}\right. $$

对比摘要A 和摘要B是否一致 **不能确保正确的公钥**->**数字证书**


#### sign
jarsign , signapk
![](https://ws1.sinaimg.cn/large/006tNc79gy1fzsg61qbs6j31gi07cjtv.jpg)

用`keytool`生成`keystore` 使用 `jarsign` 进行签名

![](https://ws1.sinaimg.cn/large/006tNc79gy1fzshd9wxj9j31630u0tlb.jpg)




# 反调试

TracerPid > 0
![](https://ws2.sinaimg.cn/large/006tNc79gy1fzs1qkattuj310b0u0nap.jpg)

![](https://ws2.sinaimg.cn/large/006tNc79gy1fzs1vbvhn4j31gw088q7a.jpg)

# apk 加固

![](https://ws3.sinaimg.cn/large/006tNc79gy1fzt1qnqxg8j31gi0g0aeo.jpg)

![](https://ws1.sinaimg.cn/large/006tNc79gy1fzt1tg52g6j31fm0byq9t.jpg)

### 解

合并
![](https://ws4.sinaimg.cn/large/006tNc79gy1fzt2m1f4r9j31bq0u0dtx.jpg)

脱壳流程
![](https://ws1.sinaimg.cn/large/006tNc79gy1fztcv0wqp4j31610u0qln.jpg)


### summary

- 源APK
- 脱壳APK = 壳dex + 壳rest
- 加密解密程序encrypt/decrypt(可以使用native来做)


加壳
classes.dex = encrypt(源APK) + 壳dex
APK = sign(classes.dex + 壳rest)

脱壳
run : APK-> classes.dex -> decrypt(加密源APK) -> 加载源APK

![](https://ws1.sinaimg.cn/large/006tNc79gy1fztdtal1e1j31eg0i20xk.jpg)


# so
<span class='heimu'>好难弄懂</span>
## so加载过程
`init_array`段是在so加载的时候执行的 执行顺序要优先于 JNI_OnLoad  所以这里是最早被执行的函数 把反调试和so的解密放到这里是比较好的选择。
`JNI_OnLoad`
![](https://ws4.sinaimg.cn/large/006tNc79gy1fzrz6w486dj31j30u0h9b.jpg)
![](https://ws1.sinaimg.cn/large/006tNc79gy1fzrzax035bj31qw0me7kd.jpg)

## apk 签名检验
![](https://ws4.sinaimg.cn/large/006tNc79gy1g04vpixokfj313a0b2tbi.jpg)
![](https://ws2.sinaimg.cn/large/006tNc79gy1g04vral1tgj31160r8guc.jpg)
```java
public class myJNI {
　　//加载so库
    static {
        System.loadLibrary("JniTest");
    }
　　//native方法
    public static native String sayHello();
}
```
调用
```java
myJNI.sayHello();
```

### 动态注册
![](https://ws2.sinaimg.cn/large/006tNc79gy1g04vzjd7n0j30v20k4tc0.jpg)
![](https://ws2.sinaimg.cn/large/006tNc79gy1g04w0rytidj30u20o8djq.jpg)
![](https://ws1.sinaimg.cn/large/006tNc79gy1g04w2m6fu1j30ur0u0du0.jpg)


## section 加固
### 原理
![](https://ws2.sinaimg.cn/large/006tNc79gy1fztjt7401sj30u00uz1bq.jpg)

### 实现
![](https://ws3.sinaimg.cn/large/006tNc79gy1fztk31o40sj316y0gaaf9.jpg)

### summary
![](https://ws3.sinaimg.cn/large/006tNc79gy1fztk70m2a2j30u011yn8b.jpg)

## 函数加密

![](https://ws4.sinaimg.cn/large/006tNc79gy1fztkaem47nj30vi0u0drn.jpg)