---
layout:     post
rewards: false
title:    img 操作
categories:
- ml
tags:
- opencv
---

一个BGR图像

# read write show

获取图片 路径不对，`imread` get None

```python
import cv2 as cv
from matplotlib import pyplot as plt


def show(*args):
    if args:
        for img in args:
            cv.imshow('', img)
            # wait 毫秒 0是永远
            cv.waitKey(0)
            cv.destroyAllWindows()


def plt_color_img(img):
    """
    彩色图片使用opencv加载是使用BGR模式，但是使用Matplotlib库是用RGB模式
    :param img:
    :return:
    """
    b, g, r = cv.split(img)
    img2 = cv.merge([r, g, b])
    plt.imshow(img2)
    plt.xticks([])
    plt.yticks([])
    plt.show()


def plt_gray_img(img):
    plt.imshow(img, cmap='gray', interpolation='bicubic')
    plt.xticks([])
    plt.yticks([])
    plt.show()


def load_img(path, mode=cv.IMREAD_COLOR):
    """
    cv.IMREAD_COLOR：加载彩色图像。任何图像的透明度都将被忽略。这是默认标志。
    cv.IMREAD_GRAYSCALE：以灰度模式加载图像
    cv.IMREAD_UNCHANGED：加载图像，包括alpha通道

    整数1,0或-1
    """
    return cv.imread(path, mode)


def save_img(path, img):
    cv.imwrite(path, img)
```


# 属性
```python
img = util.load_img('img/messi5.jpg')
# 属性
print(img.shape)  # 行数、列数、[通道数]
print(img.size)  # 总像素数
print(img.dtype)  # 数据类型

```

# 选取区域
```python
# 选择数组的区域 前5行和后3列
px = img[50, 50]
print(px)
px = img[50, 50, 0]  # 获取blue值
print(px)
px = img[50, 50, 1]  # 获取green值
print(px)
px = img[50, 50, 2]  # 获取red值
print(px)

img[50, 50] = [255, 255, 255]
print(img[50, 50])

# copy
ball = img[280:340, 330:390]
img[273:333, 100:160] = ball
util.save_img('out.jpg', img)
```

# 单个选取
```python
# 单个像素访问item() itemset()
print('\n', img[10, 10])
sca = img.item(10, 10, 0)  # 获取bgr值
print(sca)
sca = img.item(10, 10, 1)
print(sca)
sca = img.item(10, 10, 2)
print(sca)
```

# split merge
```python
# 分割和合并图像通道 split 耗时 没什么必要可以用numpy的index
b, g, r = cv.split(img)
img2 = cv.merge([r, g, b])
```

# add addWeighted

Both images should be of same depth and type, (shape and 图片后缀)or second image can just be a scalar value.

```python
"""图像运算"""
x = np.uint8([250])
y = np.uint8([10])
"""
Both images should be of same depth and type, (shape and 图片后缀)
or second image can just be a scalar value.

OpenCV添加是饱和操作，而Numpy添加是模运算。
"""
print(cv.add(x, y))  # 250+10 = 260 => 255
print(x + y)  # 250+10 = 260 % 256(2^8) = 4
img1 = util.load_img('img/ml.png')
img2 = util.load_img('img/opencv-logo.png')
print(img1.shape, img2.shape)
img2 = cv.resize(img2, (img1.shape[1], img1.shape[0]))
dst = cv.add(img1, img2)
util.show(dst)

"""
图像混合 按比例混合起来，有不同的权重 修改透明度
dst=α⋅img1+β⋅img2+γ
"""
img1 = util.load_img('img/ml.png')
img2 = util.load_img('img/opencv-logo.png')
print(img1.shape, img2.shape)
img2 = cv.resize(img2, (img1.shape[1], img1.shape[0]))
assert img1.shape == img2.shape
print(img1.shape, img2.shape)
# 有不同的权重
dst = cv.addWeighted(img1, 0.7, img2, 0.3, 0)
util.show(dst)
```

# 位运算

```python
"""
按位AND，OR，NOT和XOR运算 添加两个图像，它将改变颜色。如果我混合它，我会得到一个透明的效果

更改图像的特定区域 Region Of Interest ROI 感兴趣区域
"""
img1 = util.load_img('img/messi5.jpg')
img2 = util.load_img('img/opencv-logo-white.png')

rows, cols, channels = img2.shape
roi = img1[0:rows, 0:cols]

"""
what is mask 掩膜

0 黑 255 白

与目标图像做mask操作 目标图像扣走mask中黑色轮廓部分，保留白色区域 => 保留ROI,其他区域为0

通常mask之前
先转成灰度图像
二值化、反二值化

对自己做mask 可以抠图
提取ROI
特征提取

"""
img2gray = cv.cvtColor(img2, cv.COLOR_BGR2GRAY)
ret, mask = cv.threshold(img2gray, 10, 255, cv.THRESH_BINARY)
mask_inv = cv.bitwise_not(mask)

img1_bg = cv.bitwise_and(roi, roi, mask=mask_inv)
img2_fg = cv.bitwise_and(img2, img2, mask=mask)

util.save_img('img1_bg.png', img1_bg)
util.save_img('img2_fg.png', img2_fg)

dst = cv.add(img1_bg, img2_fg)
img1[0:rows, 0:cols] = dst
util.show(mask_inv, img1_bg, mask, img2_fg)
util.show(img1)
# util.show(mask_inv)
```

