---
layout:     post
rewards: false
title:     GC
categories:
    - py
---

## 引用计数法
```cython
typedef struct_object {
 int ob_refcnt;
 struct_typeobject *ob_type;
} PyObject;
```

在Python中每一个对象的核心就是一个结构体PyObject，它的内部有一个引用计数器（ob_refcnt）。程序在运行的过程中会实时的更新ob_refcnt的值，来反映引用当前对象的名称数量。当某对象的引用计数值为0,那么它的内存就会被立即释放掉。



一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。

它的缺点是

- **需要额外的空间维护引用计数**
- 在一些场景下，可能会比较慢。正常来说垃圾回收会比较平稳运行，但是当需要释放一个大的对象时，比如字典，需要对引用的所有对象循环嵌套调用，从而可能会花费比较长的时间

- 不过最主要的问题是它不能解决对象的“循环引用”

循环引用
![](https://tva2.sinaimg.cn/large/006tNbRwgy1fud3w978elj31kg0iq40h.jpg)

因此如果是使用引用计数法来管理这两对象的话，他们并不会被回收，它会一直驻留在内存中，就会造成了内存泄漏（内存空间在使用完毕后未释放）。为了解决对象的循环引用问题，Python引入了标记-清除和分代回收两种GC机制。


## 标记清除解决循环引用问题
- GC会把所有的**活动对象**打上标记
- 没有标记的对象**非活动对象**进行回收
![](https://tva3.sinaimg.cn/large/006tNbRwgy1fud3woxkfhj31jg0tqabx.jpg)



- 标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达
- 清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。



标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，
比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。
Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。

## 分代回收

在循环引用对象的回收中，整个应用程序会被暂停，为了减少应用程序暂停的时间

**对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。**

以空间换时间
Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象

[GC应用](https://www.cnblogs.com/Xjng/p/5128269.html)



Go

三色标记法

三色标记法是传统标记清除法 (Mark-Sweep)的一个改进，它是一个并发的 GC 算法。

首先创建三个集合：白、灰、黑。
将所有对象放入白色集合中。
然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入灰色集合。
之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
重复 4 直到灰色中无任何对象
通过write-barrier检测对象有变化，重复以上操作
收集所有白色对象（垃圾）
这个算法可以实现 “on-the-fly”，也就是在程序执行的同时进行收集，并不需要暂停整个程序。

**但是也会有一个缺陷，可能程序中的垃圾产生的速度会大于垃圾收集的速度，这样会导致程序中的垃圾越来越多无法被收集掉**

写屏障

go在进行三色标记的时候并没有进行stw（Stop-The-World），也就是说此时的对象是可以修改的。
这样就会导致在进行扫描的过程中当某个对象被另一个goroutine改变，就会导致这个对象不会被扫描到，而被误认为是白色对象。

混合写屏障会同时标记写入目标的“新指针”和“原指针”。这样就可以避免并行过程中指针不被标记或者转移指针的情况。