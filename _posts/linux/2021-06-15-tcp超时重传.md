---

layout: post
rewards: false
title:  tcp重传，滑动窗口，流量控制，拥塞控制
categories:
    - Linux

---
MSS（Maximum Segment Size，最大报文长度），是TCP协议定义的一个选项，MSS选项用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度。

RTT 就是**数据从网络一端传送到另一端所需的时间**，也就是包的往返时间。

RTO （Retransmission Timeout 超时重传时间）



# 重传机制

## 超时重传

![](https://tva1.sinaimg.cn/large/008i3skNgy1grippajesqj31gu0u0tcu.jpg)



## 快速重传

如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是**超时间隔加倍。**

也就是**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。**

超时触发重传存在的问题是，超时周期可能相对较长。

![image-20210321180058626](https://tva1.sinaimg.cn/large/008i3skNgy1gripp9rlgnj31ic0u0djx.jpg)

## 选择重传

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是**重传的时候，是重传之前的一个，还是重传所有的问题。**

因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的



### sack

发送端可以根据回传回来的SACK判断需要重传数据包（Linux内核参数：tcp_sack）

当有恶意攻击者，SACK会消耗发送端的资源

![](https://tva1.sinaimg.cn/large/008i3skNgy1gripp92p76j31j00u0wik.jpg)

如果要支持 `SACK`，必须双方都要支持。在 Linux 下，可以通过 `net.ipv4.tcp_sack` 参数打开这个功能（Linux 2.4 后默认打开）。



### D-SACK

**D-SACK**: 在TCP头加上SACK，通过ACK和SACK值判断丢失的数据包

重复收到数据问题（在 Linux 下可以通过 `net.ipv4.tcp_dsack` 参数开启/关闭这个功能), **可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。**



- ack丢失  相比sack ,ack改变了

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grippddsr1j30on0gqwg6.jpg" alt="ACK 丢包" style="zoom:67%;" />



- 数据包丢失

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1grippcfmf8j30qq0u2tck.jpg" alt="网络延时" style="zoom:67%;" />

# 滑动窗口

## 引入窗口概念的原因

数据包的**往返时间越长，通信的效率就越低**

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gripxiwsagj30du0h575d.jpg" alt="按数据包进行确认应答" style="zoom:67%;" />

TCP 引入了**窗口**这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。

那么有了窗口，就可以指定窗口大小，窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**。

窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。

**中途若有 ACK 丢失，可以通过下一个确认应答进行确认**

![用滑动窗口方式并行处理](https://tva1.sinaimg.cn/large/008i3skNgy1griq383fvdj30nt0gq767.jpg)

只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫**累计确认**或者**累计应答**。

## 窗口大小由哪一方决定

TCP 头里有一个字段叫 `Window`，也就是窗口大小。

**这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**

所以，通常窗口的大小是由接收方的窗口大小来决定的。



接收窗口的大小是**约等于**发送窗口的大小的。

> 当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是**通过 TCP 报文中的 Windows字段来告诉发送方。那么这个传输过程是存在时延的**，所以接收窗口和发送窗口是约等于的关系。





## 发送方的窗口

![img](https://tva1.sinaimg.cn/large/008i3skNgy1griqlvjq23j313o0dfwgz.jpg)

当发送方把数据**全部**都一下发送出去后，可用窗口的大小就为 0 了，表明可用窗口耗尽，**在没收到 ACK 确认之前是无法继续发送数据了**

![可用窗口耗尽](https://tva1.sinaimg.cn/large/008i3skNgy1griqn8lgzsj313o0axmyx.jpg)

在下图，当收到之前发送的数据 `32~36` 字节的 ACK 确认应答后，如果发送窗口的大小没有变化，则**滑动窗口往右边移动 5 个字节，因为有 5 个字节的数据被应答确认**，接下来 `52~56` 字节又变成了可用窗口，那么后续也就可以发送 `52~56` 这 5 个字节的数据了。

![32 ~ 36 字节已确认](https://tva1.sinaimg.cn/large/008i3skNgy1griqp9pc09j318o0bc413.jpg)

## 区分发送方的四个部分

![SND.WND、SND.UN、SND.NXT](https://tva1.sinaimg.cn/large/008i3skNgy1griqqx5b5hj313o0e941c.jpg)

- `SND.WND`：表示发送窗口的大小（大小是由接收方指定的）；
- `SND.UNA`：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。
- `SND.NXT`：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。

**可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）**

## 接收方的滑动窗口

![接收窗口](https://tva1.sinaimg.cn/large/008i3skNgy1griqt9wcdsj313o0dtwgg.jpg)

- `RCV.WND`：表示接收窗口的大小，它会通告给发送方。
- `RCV.NXT`：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。
- 指向 #4 的第一个字节是个相对指针，它需要 `RCV.NXT` 指针加上 `RCV.WND` 大小的偏移量，就可以指向 #4 的第一个字节了。







# 流量控制

发送方不能无脑的发数据给接收方，要考虑接收方处理能力。

如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。

为了解决这种现象发生，**TCP 提供一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制。**



## 操心系统的缓冲区对影响发送窗口和接收窗口

发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会**被操作系统调整**

- 服务端非常的繁忙，当收到客户端的数据时，应用层不能及时读取数据。
- 当服务端系统资源非常紧张的时候，操心系统直接减少了接收缓冲区大小，数据会溢出缓冲区，那么这时候就有严重的事情发生了，**会出现数据包丢失的现象**。

![img](https://tva1.sinaimg.cn/large/008i3skNgy1grirj348bvj30u00u9n2a.jpg)

**为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。**



**接收方向发送方通告窗口大小时，是通过 `ACK` 报文来通告的。**

那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。

![窗口关闭潜在的危险](https://tva1.sinaimg.cn/large/008i3skNgy1grirkfw2rej30uo0mzwhr.jpg)

这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。



## TCP 是如何解决窗口关闭时，潜在的死锁现象

**只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。**

如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

![窗口探测](https://tva1.sinaimg.cn/large/008i3skNgy1grirrljd14j30ww0on77h.jpg)

窗口探测

- 如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；
- 如果接收窗口不是 0，那么死锁的局面就可以被打破了。

窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 `RST` 报文来中断连接。



## 防止发送方发送小数据

到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**。

要知道，我们的 `TCP + IP` 头有 `40` 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。

- 让接收方不通告小窗口给发送方

  **窗口大小**小于 min( MSS，缓存空间/2 ) ，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 `0`，也就阻止了发送方再发数据过来。

  等到接收方处理了一些数据后，窗口大小 >= MSS，或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。

- 让发送方避免发送小数据

  使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据：

  - 要等到窗口大小 >= `MSS` 或是 数据大小 >= `MSS`
  - 收到之前发送数据的 `ack` 回包

  只要没满足上面条件中的一条，发送方一直在囤积数据，直到满足上面的发送条件。



#  拥塞控制

**流量控制是避免发送方的数据填满接收方的缓存**，但是并不知道网络的中发生了什么

**在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大**

于是，就有了**拥塞控制**，控制的目的就是**避免发送方的数据填满整个网络。**



## 拥塞窗口

**拥塞窗口 cwnd**是**发送方**维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。

我们在前面提到过发送窗口 `swnd` 和接收窗口 `rwnd` 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是**swnd = min(cwnd, rwnd)**，也就是拥塞窗口和接收窗口中的最小值。

拥塞窗口 `cwnd` 变化的规则：

- 只要网络中没有出现拥塞，`cwnd` 就会增大；
- 但网络中出现了拥塞，`cwnd` 就减少；

## 判断拥塞

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了用拥塞。**

## 拥塞算法

- 网络拥塞的原因：

- 1. 独享整个网络资源，TCP的流量控制必然会导致网络拥塞，只关注了对端接收空间，无法知道链路上的容量
  2. 路由器接入网络会拉低网络的总带宽，路由器如果出现瓶颈，很容易出现堵塞

- - 拥塞控制主要依赖于拥塞窗口(cwnd)；所以发送端发送的真正窗口是：min(rwnd,cwnd)
  - 拥塞控制的4种机制：慢开始/拥塞避免/快速重传/快速恢复
  - 拥塞控制过程:
    1. 慢启动: 进行试探的过程 -> 一般从cwnd=1开始加倍增长
    2. 当cwnd > ssthresh初始值后开始拥塞避免-> 每次cwnd+1
    3. 判断网络拥塞
       a) 没收到ACK时，重新执行慢开始，并且将sshresh初始值重置为： 发生拥塞时的cwnd/2
       b) 收到3个重复ACK时，进行快速重传，
    4. 快速恢复： 从新ssthresh=[ 发生拥塞时的cwnd/2 ]开始执行拥塞避免





有一个叫慢启动门限 `ssthresh` （slow start threshold）状态变量,一般来说 `ssthresh` 的大小是 `65535` 字节

- 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
- 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」。

![image-20210321181947219](https://tva1.sinaimg.cn/large/008i3skNgy1gripp8d4l5j31ir0u0n2c.jpg)

![image-20210321182411996](https://tva1.sinaimg.cn/large/008i3skNgy1gripp8kf4bj31g00u0adz.jpg)

# TCP如何保证可靠性

1. TCP分段：应用数据被分割成合适的TCP段发送（对UDP来说，应用程序产生的数据段长度将保持不变）
  2. 超时重传：每发出一个TCP段都会启动一个"重传定时器"；如果不能及时收到一个确认，将重传这个报文段
  3. 流量控制：缓冲区固定大小，TCP接收端只允许另一端发送接收缓冲区所能接纳的数据（滑动窗口）
  4. 数据校验：TCP首部(校验和)；如果收到段的校验和有差错，会选择丢弃和不确认
  5. 处理IP数据包：a) 丢弃重复的IP数据包；b) 将失序的IP数据包重新排序后交



![](https://tva1.sinaimg.cn/large/008i3skNgy1grippcxl1rj31ca0ey0u6.jpg)