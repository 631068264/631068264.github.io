---
layout:     post
rewards: false
title:      锁
categories:
    - mysql
---

# InnoDB 排他锁
* for update仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。
* 其他线程对该记录的更新与删除操作都会阻塞
* 排他锁包含行锁、表锁 (没有用到索引引起表锁  还有like <> )
* 部分条件符合也会针对索引字段锁上(会做成多行锁) 只有所有条件完全不符合的时候才不会上锁

# 一致性解决方案
## 悲观锁

加排他锁 适合写入频繁的场景
```
begin;
select * from goods where id = 1 for update;
update goods set stock = stock - 1 where id = 1;
commit;
```

## 乐观锁
乐观锁方案：每次获取商品时，不对该商品加锁。在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新，反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。乐观锁适合读取频繁的场景

```
#不加锁获取 id=1 的商品对象
select * from goods where id = 1

begin;
#更新 stock 值，这里需要注意 where 条件 “stock = cur_stock”，只有程序中获取到的库存量与数据库中的库存量相等才执行更新
update goods set stock = stock - 1 where id = 1 and stock = cur_stock;
commit;
```

# 共享锁

获准共享锁的事务只能读数据，不能写。 共享锁下其它用户可以并发读取，查询数据。但不能修改，增加，删除数据。

# 排它锁

若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁

# 分布式锁

Zookeeper 的有序节点

- 永久节点：不会因为会话结束或者超时而消失

- 临时节点：如果会话结束或者超时就会消失 

- 有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，依次类推

创建一个锁目录 /lock。 在 /lock 下创建**临时的且有序的子节点**（临时的就不会死锁），

第一个客户端对应的子节点为 /lock/lock-0000000000，第二个为 /lock/lock-0000000001，以此类推。
客户端获取 /lock 下的子节点列表，判断自己创建的子节点**是否为当前子节点列表中序号最小的子节点**，如果是则认为获得锁。
否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁。 执行业务代码，完成后，删除对应的子节点。



# 事务

事务具有4个特性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。

- **原子性（atomicity）：**一个事务应该是一个不可分割的工作单位，事务中包括的操作要么都成功，要么都不成功。
- **一致性（consistency）：**事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。
- **隔离性（isolation）：**一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据在事务未提交前对并发的其他事务是隔离的，并发执行的各个事务之间不能互相影响。
- **持久性（durability）：**一个事务一旦成功提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

## 并发事务存在问题

**脏读**

脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。



**不可重复读**

不可重复读是指在对于数据库中的某条数据，一个事务范围内多次查询返回不同的数据值(这里不同是指某一条或多条数据的内容前后不一致，但数据条数相同)，这是由于在查询间隔，该事务需要用到的数据被另一个事务修改并提交了。

**不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了其他事务提交的数据。需要注意的是在某些情况下不可重复读并不是问题。**



**幻读**

幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。

而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。

幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中。



# 在事务中存在以下几种隔离级别

**读未提交(Read Uncommitted)**

解决更新丢失问题。如果一个事务已经开始写操作，那么其他事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据不需要加 S 锁。

**读已提交(Read Committed)**

解决了脏读问题。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。这可以通过“瞬间共享读锁”和“排他写锁”实现， 即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事务结束。

**可重复读取(Repeatable Read)**

禁止不可重复读取和脏读取，但是有时可能出现幻读数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。

Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事务结束后再释放。

**串行化(Serializable)**

解决了幻读的问题的。提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。