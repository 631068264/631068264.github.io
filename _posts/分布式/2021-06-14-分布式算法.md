---
layout:     post
rewards: false
title:      分布式算法
categories:
    - 分布式
tags:
    - 分布式
---

# Paxos

- **Proposer**（提案人）只有一个
- **Acceptor**（接收者）多个
- **Learners**（学习者）多个

对于一致性算法，安全性（safaty）要求如下：

- 只有被提出的 `value` 才能被选定。
- 只有一个 `value` 被选定
- 如果某个进程认为某个 `value` 被选定了，那么这个 `value` 必须是真的被选定的那个。

一致性算法的目标是保证最终有一个提出的 `value` 被选定。当一个 `value` 被选定后，进程最终也能学习到这个 `value`。



**阶段一**

1. Proposer 选择一个提案编号 N，然后向半数以上的 Acceptor 发送编号为 N 的 Prepare 请求。

   > Proposer 生成提案之前，应该先去学习已经被选定或者可能被选定的 value，然后以该 value 作为自己提出的提案的 value。如果没有 value 被选定，Proposer 才可以自己决定 value 的值。这样才能达成一致。这个学习的阶段就是通过一个 **Prepare 请求**实现。

2. 如果 Acceptor 收到一个编号为 N 的 Prepare 请求，且 **N > 该 Acceptor 已经响应过的所有 Prepare 请求的编号**，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于N的提案。

**阶段二**

1. 如果 Proposer **收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应**，那么它就会发送一个针对

   ```
   [N,V]
   ```

   提案的 Accept 请求给半数以上的 Acceptor。如果响应中不包含任何提案，那么 V 就由 Proposer 自己决定

   > V 就是收到的响应中编号最大的提案的 value。

2. 如果 Accepter 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号大于 N 的 Prepare 请求作出响应，它就接收该提案。

Learner 学习（获取）被选定的value有以下三种方案：

[![Learner学习选定value方案](https://tva1.sinaimg.cn/large/008i3skNgy1grhuu40upmj30hs0a0ab1.jpg)](https://qiniu.xiaoming.net.cn/Learner学习选定value方案.webp)

疑问

- 为什么要用“半数以上通过”

  过半的思想保证提交的value在同一时刻在分布式系统中是唯一的一致的。

- 当Proposer有很多个的时候，会有什么问题

  很难有一个proposer收到半数以上的回复，进而不断地执行第一阶段的协议，决策收敛速度慢，很久都不能做出一个决策。
  
- 提案为什么要带上编号
  
  为了acceptor可以在自身接受到的提案的对比中做出最终的唯一决策。
  
  
# RAFT

Raft将系统中的角色分为领导者（Leader）、跟从者（Follower）和候选人（Candidate）：

- **Leader**：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。
- **Follower**：接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。
- **Candidate**：Leader选举过程中的临时角色。

Raft要求系统在任意时刻最多只有一个Leader，正常工作期间只有Leader和Followers。



## Leader选举

Raft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。

Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。

Follower将其**当前任期（term）**加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC 

三种情况

- 赢得了多数的选票，成功选举为Leader；
- 收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；
- 没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。

选举出Leader后，Leader通过定期向所有Followers发送心跳信息维持其统治。若Follower一段时间未收到Leader的心跳则认为Leader可能已经挂了，再次发起Leader选举过程。

## 日志同步

每次改变数据先记录日志，日志未提交不能改节点的数值。然后 `LEADER` 会复制数据给其他 `Follower` 节点，并等大多数节点写日志成功再提交数据。

![img](https://tva1.sinaimg.cn/large/008i3skNgy1grhv97n8o6j31400p7gmp.jpg)

某些Followers可能没有成功的复制日志，Leader会无限的重试 AppendEntries RPC直到所有的Followers最终存储了所有的日志条目。

日志由有序编号（log index）的日志条目组成。每个日志条目包含它被创建时的任期号（term），和用于状态机执行的命令。如果一个日志条目被复制到大多数服务器上，就被认为可以提交（commit）了。

Raft日志同步保证如下两点：

- 如果不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。
- 如果不同日志中的两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。



## 安全性

- 拥有最新的已提交的log entry的Follower才有资格成为Leader。

  Candidate在发送RequestVote RPC时，要带上自己的最后一条日志的term和log index，其他节点收到消息时，如果发现自己的日志比请求中携带的更新，则拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term更大，则term大的更新，如果term一样大，则log index更大的更新。

  