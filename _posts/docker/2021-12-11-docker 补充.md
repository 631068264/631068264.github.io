---
layout:     post
rewards: false
title:      docker 补充
categories:
    - docker

---

# docker run 参数补充

[**--pid**](https://docs.docker.com/engine/reference/run/#pid-settings---pid) 为容器设置pid (进程) namespace mode


- 'container:<name|id>': joins another container's PID namespace
- 'host': use the host's PID namespace inside the container

PID namespace 默认进程隔离，移除系统宿主机进程，复用pid 1。

[**--uts**](https://docs.docker.com/engine/reference/run/#uts-settings---uts) 设置hostname和downmain

- 'host': use the host's UTS namespace inside the container

**docker run --uts=host ubuntu hostname** 创建宿主机主机名的容器

[--ipc](https://docs.docker.com/engine/reference/run/#ipc-settings---ipc) 设置共享内存

IPC (POSIX/SysV IPC) namespace provides separation of named shared memory segments, semaphores and message queues.

# 问答

> 已运行 docker run -d -t —name demo ubuntu top 和 docker run --name demo-x --pid container:demo ubuntu ps 命令，如果 demo 容器退出了，正在运行的 demo-x 容器是否会退出？

是

> 已知容器 Init 进程 PID，在宿主机上通过 kill -9 PID 的方式结束该进程，容器当前的状态是什么？

Exited



> 已运行 docker run -d -t —name demo ubuntu top 命令, 在 demo 这个容器内看到 top 命令的 PID 是什么？

1



> 已运行 docker run -d -t —name demo ubuntu top 命令, docker exec -it demo kill -9 1 强行给容器内一号进程发KILL信号，容器是否会退出

否

> 已运行 docker run -d —name demo busybox:1.25 top 命令，如何使用 docker 命令来获取容器 demo 的 Init 进程 PID？

`docker inspect demo -f '{{.State.Pid}}'`

# pid 1

在Linux操作系统中，当内核初始化完毕之后，会启动一个init进程，这个进程是整个操作系统的第一个用户进程，所以它的进程ID为1，也就是我们常说的PID1进程。在这之后，**所有的用户态进程都是该进程的后代进程**，由此我们可以看出，**整个系统的用户进程，是一棵由init进程作为根的进程树。**

**SIGKILL信号对它无效**，很显然，如果我们将一棵树的树根砍了，那么这棵树就会分解成很多棵子树，这样的最终结果是导致整个操作系统进程杂乱无章，无法管理。

## 基本概念

### 进程表项

linux内核程序通过进程表对进程进行管理, 每个进程在进程表中占有一项，记录了进程的状态，打开的文件描述符等等一系统信息。称为**进程表项**。

当一个进程结束了运行或在半途中终止了运行，那么内核就需要释放该进程所占用的系统资源。这包括进程运行时打开的文件，申请的内存等。**但是，进程表项并没有随着进程的退出而被清除，它会一直占用内核的内存。**

> 这是因为在某些程序中，我们必须明确地知道进程的退出状态等信息，而这些信息的获取是由父进程调用wait/waitpid而获取的。设想这样一种场景，如果子进程在退出的时候直接清除文件表项的话，那么父进程就很可能没有地方获取进程的退出状态了，因此操作系统就会将文件表项一直保留至wait/waitpid系统调用结束。

## 僵尸进程

监视进程：**进程退出后，到其父进程还未对其调用wait/waitpid之间的这段时间所处的状态。**

一般来说，这种状态持续的时间很短，所以我们一般很难在系统中捕捉到。但是，一些粗心的程序员可能**会忘记调用wait/waitpid，或者由于某种原因未执行该调用等等，那么这个时候就会出现长期驻留的僵尸进程了。如果大量的产生僵尸进程，其进程号就会一直被占用，可能导致系统不能产生新的进程。** 列如：父进程先于子进结束

## 孤儿进程

**父进程先于子进程退出，那么子进程将成为孤儿进程**。孤儿进程将**被init进程(进程号为1)接管**，并由init进程对它完成状态收集(wait/waitpid)工作。

PID 1负责清理那些被抛弃的进程所留下来的痕迹，有效的回收的系统资源，保证系统长时间稳定的运行，可谓是功不可没。



# 容器里的pid1

容器并不是一个完整的操作系统，它没有什么内核初始化过程。

在容器中被标志为PID 1的进程实际上就是**一个普普通通的用户进程**，也就是我们制作镜像时在Dockerfile中指定的**ENTRYPOINT**的那个进程。

这个进程在宿主机上有一个普普通通的进程ID，而在容器中之所以变成PID 1，是因为linux内核提供的[PID namespaces](https://lwn.net/Articles/531419/)功能，如果宿主机的所有用户进程构成了一个完整的树型结构，那么PID namespaces实际上就是将这个ENTRYPOINT进程（包括它的后代进程）从这棵大树剪下来。

```shell
# 可以看容器内部pid
docker run -t --name demo ubuntu top

top - 14:11:16 up 11 min,  0 users,  load average: 0.67, 0.31, 0.17
Tasks:   1 total,   1 running,   0 sleeping,   0 stopped,   0 zombie
%Cpu(s): 15.2 us,  9.1 sy,  0.0 ni, 70.2 id,  4.3 wa,  0.0 hi,  1.2 si,  0.0 st
MiB Mem :   7960.4 total,   5621.1 free,    734.2 used,   1605.1 buff/cache
MiB Swap:   1024.0 total,   1024.0 free,      0.0 used.   6634.8 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    1 root      20   0    6092   3180   2684 R   0.0   0.0   0:00.24 top


➜  ~ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED          STATUS          PORTS     NAMES
7803046303b4   ubuntu    "top"     13 seconds ago   Up 11 seconds             demo

# pid 是宿主机pid ppid是父进程id
➜  ~ docker top 7803046303b4
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                8090                8065                0                   14:08               ?                   00:00:00            top

# 可以看容器内部pid
cat /proc/8090/status | grep NSpid
NSpid:  8090   1
```

容器外部kiss -9 8090，那整个容器便会处于退出状态

![Docker](https://tva1.sinaimg.cn/large/008i3skNgy1gxaa5hiyu8j31ni0n240v.jpg)

从架构图中我们可以看到shim进程下还有一个runC进程，但我们在进程树中并没有发现runC这个进程。

**runC**是OCI标准的一个参考实现，而OCI Open Container Initiative，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作。runc，是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程。



Docker容器的创建过程是这样子的 **docker-containerd-shim –> runC –> entrypoint**，而我们看到的最终状态是 **docker-containerd-shim –> entrypoint**，聪明的你可能已经猜到，**runc进程创建完容器之后，自己就先退出去了**。但是这里面其实暗藏了一个问题，按照前面提到的孤儿进程理论，entrypint进程应该由操作系统的PID 1进程接管，但为什么会被shim接管呢？

## [PR_SET_CHILD_SUBREAPER](http://man7.org/linux/man-pages/man2/prctl.2.html?spm=a2c4e.11153940.blogcont61894.11.14a950abm8s9Ha)

> linux在内核3.14以后版本支持该系统调用，它可以将调用进程标记“child subreaper”属性，而拥有该属性的进程则可以充当init(1)进程的功能，收养其后代进程中所产生的孤儿进程。我们可以从shim的源码中找到答案
>
> ```go
> func start(log *os.File) error {
>      // start handling signals as soon as possible so that things are properly reaped
>      // or if runtime exits before we hit the handler
>      signals := make(chan os.Signal, 2048)
>      signal.Notify(signals)
>      // set the shim as the subreaper for all orphaned processes created by the container
>      if err := osutils.SetSubreaper(1); err != nil {
>          return err
>      }
>      ...
>  }
> ```
>
> 既然充当了reaper的角色，那么就应该尽到回收资源的责任：
>
> ```go
> func start(log *os.File) error {
>     ...
>     switch s {
>         case syscall.SIGCHLD:
>             exits, _ := osutils.Reap(false)
>             ...
>     }
>     ...
> }
> func Reap(wait bool) (exits []Exit, err error) {
>    ...
>    
>    for {
>        pid, err := syscall.Wait4(-1, &ws, flag, &rus)
>        if err != nil {
>            if err == syscall.ECHILD {
>                return exits, nil
>            }
>            return exits, err
>        }
>        
>        ...
>    }
> }
> ```
>
> 从这里我们可以看到shim的wait/waitpid系统调用。
