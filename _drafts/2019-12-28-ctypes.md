---
layout:     post
rewards: false
title:      DDL
categories:
    - hack
tags:
    - security
---

# DDL

解析和访问动态链接库中的函数

**dynamically linked library**(动态连接库 DDL)其实就是一个二进制文件,一般由别的程序调用执行

- Windows 上叫做 dynamic link libraries (DLL)动态链接库
- 在 Linux 上叫 做 shared objects (SO)共享库

正常情况下 ，要调用函数，都必须先解析出函数地址


ctypes 提供了三种方法调用动态链接库 :cdll(), windll(), 和 oledll()。它们的不同之处就在 于，函数的调用方法和返回值。 cdll() 加载的库，
其导出的函数必须使用标准的 cdecl 调用 约定。windll()方法加载的库，其导出的函数必须使用 stdcall 调用约定(Win32 API 的原生约 定)
。oledll()方法和 windll()类似，不过如果函数返回一个 HRESULT错误代码，可以使 用 COM 函数得到具体的错误信息。

![](https://tva1.sinaimg.cn/large/006tNbRwly1gaddpzakglj312u0u0tad.jpg)

联合和结构很像 。但是联合中所有变量同处一个内存地址 ，只占用一个变量的内存空间 ， 这个空间的大小就是最大的那个变量的大小 。这样就能够将联合作为不同类型的变量操作访问了。

<span class='gp-2'>
    <img src='https://tva1.sinaimg.cn/large/006tNbRwly1gadedyunwbj30c60d4glj.jpg' />
    <img src='https://tva1.sinaimg.cn/large/006tNbRwly1gade9ajt5yj30ga0dw0st.jpg' />
    <img src='https://tva1.sinaimg.cn/large/006tNbRwly1gadeal640sj30i409e0sr.jpg' />
    <img src='https://tva1.sinaimg.cn/large/006tNbRwly1gadeb12cawj30hc0bat8u.jpg' />
</span>

将一个整数赋值给联合中的 barley_int，接着我们就能够调用
barley_char，用字符的形式显示刚才输入的整数，**联合赋一个值就能得到三种不同的表现方式**。


# 黑盒

黑盒测试分成两种不同的模式:用户模式 和 内核模式。

- 用户模式(通常指的是 ring3 级的程序)是你平时运行用户程序的一般模式(普通的程序 )。用户模式的权限是最低的。
- 核心模式的权限是最高的 。这里运行着操作系统内核，驱动程序，底层组件。

# CPU寄存器

CPU 的寄存器能够对少量的数据进行快速的存取访问

- **EAX** 累加寄存器，除了用于**存储函数的返回值**外也用于执行计算的操作。
- **EDX** 从本质上来说是EAX寄存器的延伸， 它辅助EAX完成更多复杂的计算操作像乘法和除法。能当作通用寄存器使用 ，不 过更多的是结合 EAX 寄存器进行计算操作
- **ECX** 计数寄存器，用于循环操作，比如重复的字符存储操作，或 者数字统计，** ECX 寄存器的计算是向下，循环操作时是由大减到小的**。

    ![](https://tva1.sinaimg.cn/large/006tNbRwly1gadfekdew2j31e00foab9.jpg)

- **ESI 和 EDI** 寄存器能对需要**循环操作的数据进行高效的处理** 。 ESI 寄存器是源操作数指针，存储着输入的数据流的位置。 EDI
 寄存器是目的操作数指针 ， 存储了计算结果存储的位置 。简而言之，ESI(source index)用于读，EDI(destination
 index) 用于写。用源操作数指针和目的操作数指针，极大的提高了程序处理数据的效率。

- **ESP 和 EBP 分别是栈指针和基指针**。这两个寄存器共同**负责函数的调用和栈的操作**。
当一个函数被调用的时候 ，函数需要的参数被陆续压进栈内最后函数的返回地址也被压进。ESP 指着栈顶，也就是返回地址。
EBP 则指着栈的底端。有时候，编译器能够做出优化，释放 EBP，使其不再用于栈的操作，只作为普通的寄存器使用。

- **EBX** 是唯一一个没有特殊用途的寄存器。它能够作为额外的数据储存器。

- **EIP**这个寄存器总是指向马上要执行的指令 。当 CPU 执行一个程序的成千上万的代码的时候 ，EIP 会实时的指向当前 CPU 马上要执行到的位置。


**指令**会被汇编器转换成**操作码**(opcode)就是 operation code，CPU 能理解并执行的语言

`0x44332211: 8BC3 MOV EAX, EBX`

> 指令`MOV EAX, EBX`发生在 `0x4433221` 这个地址,操作码`8BC3`


## 栈调用

栈是一个非常重要的结构 。栈存储了与函数调用相关的各种信息，包括函数的参数和函数执行完成后返回的方法。
**ESP**负责跟踪栈顶，**EBP** 负责跟踪栈底。 **栈从内存的高地址向低地址增长**

<span class='gp-2'>
    <img src='https://tva1.sinaimg.cn/large/006tNbRwly1gadgvv40gyj31bw0pkt94.jpg' />
    <img src='https://tva1.sinaimg.cn/large/006tNbRwly1gadh391i01j31e40tcwfq.jpg' />
</span>

## 断点

###  软件断点

软件断点具体而言就是在 CPU 执行到特定位置的代码的时候使其暂停。软件断点将会使你在调试过程中用的最多的断点 。
**软件断点的本质就是一个单字节的指令** ，用于暂停被执行程序，并将控制权转移给调试器的断点处理函数。

这个单字节的操作码也就 是3号中断指令(INT3)，一条能让CPU暂停的指令。3号中断转换成操作码就是 0xCC

#### 原理

```
0x44332211: CCC3 MOV EAX, EBX
```

原操作码中的 8B 被替换成了 CC。当 CPU 执行到这个操作码的时候 ，CPU 暂停， 并触发一个 INT3(3 号中断)事件。

- 当调试器被告知在目标地址设置一个断点 ，读取目标地址的第一个字节的**操作码** ，然后保存起来，同时把**地址**存储在内部的中断列表中。
- 调试器把一个字节操作码 CC 写入刚才的地址。当 CPU 执行到 CC 操作码的 时候就会触发一个 INT3 中断事件，此时调试器就能捕捉到这个事件 。
- 调试器继续判断这个发生中断事件的地址 (通过 EIP 指针，指令指针)是不是自己先前设置断点的地址 。
如果在调试器内部的断点列表中找到了这个地址，就将设置断点前存储起来的操作码写回到目标地址，这样进程被调试器恢复后就能正常的执行。


#### 缺点

当你改变了被调试程序的内存数据的时候 ，你同时改变了运 行时的软件的循环冗余码校验合 (CRC)。CRC 是一种校验数据是否被改变的函数，
将一定 范围内的数据进行 hash(散列)计算，在逆向工程中一般是对进程的内存数据进行运算， 然后将 hash 值和此前原始的 hash 值进行比较，以判断数据是否被改变。

程序运行时可能会CRC检测，自己kill自己。为了在这种特殊的情况下也能正常的 进行调试工作，就要使用硬件断点了。

### 硬件断点

这种类型的断点被设置在 CPU 级别，并用特定的寄存器:调试寄存器。一个 CPU 一般会有 8 个调试寄存器(DR0 寄存器到 DR7
寄存器)，它们被用于管理硬件断点 。

#### 原理

调试寄存器 DR0 到调试寄存器 DR3 存储硬件断点地址。**这意味着你同一时间内最多只能有 4 个硬件断点**。
DR4 和 DR5 保留。DR6 是状态寄存器，说明了被断点触发的调试事件的类型 。DR7 本质上 是一个硬件断点的开关寄存器，同时也存储了断点的不同类型。

DR7 寄存器里设置 不同标志，能够创建以下几种断点:
- 当特定的地址上有指令执行的时候中断
- 当特定的地址上有数据可以写入的时候
- 当特定的地址上有数据读或者写但不执行的时候

硬件断点不是用 INT3 中断，而是用 INT1(1 号中断).INT1 负责硬件 中断和步进事件。
步进( Single-step )意味着一步一步的执行指令，从而精确的观察关键 代码以便监视数据的变化。

CPU 每次执行代码之前，都会先确认当前将执行的代码的地 址是否是硬件断点的地址，同时也要确认是否有代码要访问被设置了硬件断点的内存区域 。
如果任何储存在 DR0-DR3 中的地址所指向的区域被访问了，就会触发 INT1 中断，同时暂 停 CPU。如果没有，CPU 执行代码，到下一行代码时，CPU 继续重复上面的检查

#### 缺点

- 同一时间只能设置四个断点
- 断点起作用的区域只有 4 个字节(也就是检测 4 个字节的内存数据改变)。如果你想 跟踪一大块内存数据，就办不到了

### 内存存断点

内存断点其实不是真正的断点。当一个调试器设置了一个内存断点的时候，它其实是 改变了内存中某个块或者页的权限 。
一个内存页是操作系统处理的最小的内存单位 。一个内 存页被申请成功以后 ，就拥有了一个权限集 ，它决定了内存该如何被访问 。

内存页的访问权限 rwx 。 任何对保护页(GuardPage)的访问都会引发异常，之后页面恢复访问前的状态。

- 分离堆和栈或者 确保一部分内存数据不会增长出边界。
- 当一个特定的内存块被进程命中(访问)了，就暂停进程

举个例子，如果我们在逆向一个网络服务程序 ，在其接收到网络数据 包以后，我们**在存储数据包的内存上设置保护页** ，
接着运行程序，一旦有任何对保护页的访 问，都会使 CPU 暂停，抛出一个保护页调试异常，
这时候我们就能确定程序是在什么时候 用什么方式访问接收到的数据了 。之后再进一步跟踪观察访问内存的指令 ，继而确定程序对
数据做了什么操作。这种断点同时也解决了软件断点数据更新的问题 ，因为我们没有修改任何运行着的代码。